<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta name="color-scheme" content="light dark">
  <title>MermaidPad Preview</title>
  <style>
    /* Paint correctly on first frame based on OS theme */
    html, body {
      margin: 0;
      height: 100%;
      background: #fff;
      color: #222;
    }

    @media (prefers-color-scheme: dark) {
      html, body {
        background: #1e1e1e;
        color: #ddd;
      }
    }

    body.dark-theme {
      background: #000;
      color: #ddd;
    }

    body.light-theme {
      background: #fff;
      color: #222;
    }

    /* CSS custom property for transition duration */
    :root {
      --loading-transition-duration: 300ms;
    }

    #output {
      padding: 8px;
      overflow: auto;
      height: 100vh;
      box-sizing: border-box;
      display: none;
    }

      #output.visible {
        display: block;
      }

    .error {
      color: #ff6f6f;
      white-space: pre;
      font-family: Consolas,monospace;
    }

    /* Loading indicator styles */
    #loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      transition: opacity var(--loading-transition-duration) ease-out, visibility 0s ease-out var(--loading-transition-duration);
    }

      #loading-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

    .spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 0.1875rem solid rgba(0, 0, 0, 0.1);
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spinner-rotate 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    body.dark-theme .spinner {
      border-color: rgba(255, 255, 255, 0.1);
      border-top-color: #4db8ff;
    }

    #loading-container.hidden .spinner {
      animation: none;
    }

    @keyframes spinner-rotate {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loading-status {
      position: absolute;
      top: calc(50% + 3rem);
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 1rem;
      color: #666;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      white-space: nowrap;
      will-change: transform;
    }

    body.dark-theme #loading-status {
      color: #aaa;
    }

    /* Mermaid dark theme overrides */
    body.dark-theme #output svg .messageLine,
    body.dark-theme #output svg .actor-line,
    body.dark-theme #output svg .mermaid .edgePath path,
    body.dark-theme #output svg .mermaid .node rect,
    body.dark-theme #output svg .mermaid .node circle,
    body.dark-theme #output svg .mermaid .node ellipse {
      stroke: #e0e0e0 !important;
    }

    body.dark-theme #output svg text,
    body.dark-theme #output svg .messageText {
      fill: #e0e0e0 !important;
    }
  </style>
  <!-- Apply theme immediately before any scripts load -->
  <script>
    // Immediate theme application to prevent flash
    (function() {
        const getSystemTheme = () => {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').media !== 'not all') {
                return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
            }
            return 'default';
        };

        const applyTheme = theme => {
            document.body.classList.toggle('dark-theme', theme === 'dark');
            document.body.classList.toggle('light-theme', theme === 'default');
        };

        // Store functions globally for reuse
        window.getSystemTheme = getSystemTheme;
        window.applyTheme = applyTheme;
        window.currentTheme = getSystemTheme();

        // Apply theme immediately if body exists
        if (document.body) {
            applyTheme(window.currentTheme);
        } else {
            // If body doesn't exist yet, apply on DOMContentLoaded
            document.addEventListener('DOMContentLoaded', function() {
                applyTheme(window.currentTheme);
            }, { once: true });
        }
    })();
  </script>

  <!-- Load js-yaml first, no defer to avoid races -->
  <script src="js-yaml.min.js" id="jsyaml-script"></script>

  <!-- Load Mermaid, no defer to avoid races -->
  <script src="mermaid.min.js" id="mermaid-script"></script>

  <!-- Main initialization with proper event-driven loading -->
  <script type="module">
    // Global flags
    window.elkLayoutAvailable = false;
    window.mermaidInitialized = false;

    // Promise-based script loading with timeout
    function waitForScriptLoad(scriptId, timeout = 5000) {
        return new Promise((resolve, reject) => {
            const script = document.getElementById(scriptId);

            if (!script) {
                reject(new Error(`Script element with id '${scriptId}' not found`));
                return;
            }

            // Check if already loaded
            if (scriptId === 'mermaid-script' && typeof window.mermaid !== 'undefined') {
                resolve();
                return;
            }
            if (scriptId === 'jsyaml-script' && typeof window.jsyaml !== 'undefined') {
                resolve();
                return;
            }

            // Set up timeout
            const timeoutId = setTimeout(() => {
                reject(new Error(`Script '${scriptId}' load timeout after ${timeout}ms`));
            }, timeout);

            // Set up load event listener
            const handleLoad = () => {
                clearTimeout(timeoutId);
                resolve();
            };

            const handleError = (error) => {
                clearTimeout(timeoutId);
                reject(new Error(`Script '${scriptId}' failed to load: ${error.message || 'Unknown error'}`));
            };

            script.addEventListener('load', handleLoad, { once: true });
            script.addEventListener('error', handleError, { once: true });
        });
    }

    // Load ELK layout module
    async function loadElkLayout() {
        try {
            const elkModule = await import('./mermaid-elk-layout/mermaid-layout-elk.esm.min.mjs');
            const elkLayouts = elkModule.default;

            // Register ELK layouts with Mermaid
            window.mermaid.registerLayoutLoaders(elkLayouts);
            window.elkLayoutAvailable = true;
            console.log('ELK layout registered successfully');
            return true;
        } catch (err) {
            console.error('Failed to load ELK layout:', err);
            console.log('Continuing without ELK layout support');
            return false;
        }
    }

    // Main initialization function
    async function initializeApplication() {
        try {
            // Wait for both scripts to load
            console.log('Waiting for scripts to load...');
            await Promise.all([
                waitForScriptLoad('jsyaml-script'),
                waitForScriptLoad('mermaid-script')
            ]);

            console.log('Scripts loaded, initializing Mermaid...');

            // Update loading status
            window.updateLoadingStatus('Loading rendering engine...');

            // Try to load ELK layout
            await loadElkLayout();

            // Initialize mermaid (with or without ELK)
            window.mermaid.initialize({
                startOnLoad: false,
                theme: window.currentTheme
            });

            // Set initialization flag
            window.mermaidInitialized = true;
            console.log('Mermaid initialized successfully');

            // Process any pending render
            if (window.pendingMermaidRender) {
                console.log('Processing pending render...');
                window.renderMermaid(window.pendingMermaidRender);
                window.pendingMermaidRender = null;
            }
        } catch (error) {
            console.error('Failed to initialize application:', error);
            // Set flag to prevent infinite retries
            window.mermaidInitializationFailed = true;

            // Hide loading indicator and show error
            window.hideLoadingIndicator();

            const output = document.getElementById('output');
            if (output) {
                output.classList.add('visible');
                output.innerHTML = `<div class="error">Failed to initialize: ${error.message}</div>`;
            }
        }
    }

    // Start initialization
    initializeApplication();

    // Setup theme change listener
    document.addEventListener('DOMContentLoaded', () => {
        // Theme is already applied, but listen for changes
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                window.currentTheme = e.matches ? 'dark' : 'default';
                window.applyTheme(window.currentTheme);

                // Re-render if we have content and Mermaid is initialized
                if (window.lastMermaidSource && window.mermaidInitialized) {
                    // Re-initialize Mermaid with new theme
                    window.mermaid.initialize({
                        startOnLoad: false,
                        theme: window.currentTheme
                    });
                    window.renderMermaid(window.lastMermaidSource);
                }
            });
        }
    });
  </script>
  <!-- Render functions in separate script -->
  <script>
        // Important SVG properties to inline (module-level constant)
        const inlineStyleSVGProps = Object.freeze([
            'fill',
            'stroke',
            'stroke-width',
            'font-family',
            'font-size',
            'text-anchor',
            'dominant-baseline'
        ]);

        // Get transition duration from CSS custom property
        const getTransitionDuration = () => {
            const duration = getComputedStyle(document.documentElement)
                .getPropertyValue('--loading-transition-duration')
                .trim();
            // Remove 'ms' suffix and convert to number
            const numericValue = parseFloat(duration.replace('ms', ''));
            return isNaN(numericValue) ? 300 : numericValue; // Fallback to 300ms if parsing fails
        };

        // Loading indicator management
        window.updateLoadingStatus = (message) => {
            const statusElement = document.getElementById('loading-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
        };

        window.hideLoadingIndicator = () => {
            const loadingContainer = document.getElementById('loading-container');
            const output = document.getElementById('output');

            if (loadingContainer) {
                loadingContainer.classList.add('hidden');
                // Remove from DOM after transition completes (duration from CSS variable)
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, getTransitionDuration());
            }

            if (output) {
                output.classList.add('visible');
            }
        };

        // Render function with proper error handling
        window.renderMermaid = source => {
            window.lastMermaidSource = source; // Save for re-rendering
            const output = document.getElementById('output');

            // Helper functions
            const createErrorElement = (message) => {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message; // XSS-safe
                return errorDiv;
            };

            const showError = (message) => {
                // Hide loading indicator and show error
                window.hideLoadingIndicator();
                output.innerHTML = '';
                output.appendChild(createErrorElement(message));
            };

            // ReSharper disable once InconsistentNaming
            const setSafeSVG = (htmlContent) => {
                const trimmed = htmlContent.trim();
                if (trimmed.startsWith('<svg') && trimmed.includes('</svg>')) {
                    output.innerHTML = htmlContent;
                } else {
                    showError('Invalid diagram content received');
                }
            };

            // Check if initialization failed
            if (window.mermaidInitializationFailed) {
                showError('Mermaid initialization failed. Please refresh the page.');
                return;
            }

            // Check if mermaid is initialized
            if (!window.mermaidInitialized) {
                // Store for later rendering
                window.pendingMermaidRender = source;

                // Check if we should retry (with limit)
                if (!window.renderRetryCount) {
                    window.renderRetryCount = 0;
                }

                if (window.renderRetryCount < 10) {
                    window.renderRetryCount++;
                    setTimeout(() => window.renderMermaid(source), 200);
                    return;
                } else {
                    showError('Mermaid is still loading. Please try again.');
                    window.renderRetryCount = 0;
                    return;
                }
            }

            // Reset retry count on successful initialization
            window.renderRetryCount = 0;

            // Parse front-matter config if present
            const fmRegex = /^---\s*([\s\S]*?)---\s*/;
            let diagramSource = source;
            const match = source.match(fmRegex);

            if (match) {
                try {
                    const parsed = window.jsyaml.load(match[1]);
                    if (parsed && parsed.config) {
                        const customConfig = parsed.config;

                        // Re-initialize with new config
                        const configWithTheme = {
                            ...customConfig,
                            theme: customConfig.theme || window.currentTheme,
                            startOnLoad: false
                        };

                        // Log config for debugging if using ELK
                        if (window.elkLayoutAvailable && customConfig.flowchart?.defaultRenderer === 'elk') {
                            console.log('Using ELK layout with config:', configWithTheme);
                        }

                        window.mermaid.initialize(configWithTheme);
                    }
                    // Remove front-matter from diagram source
                    diagramSource = source.replace(fmRegex, "");
                } catch (err) {
                    showError(`YAML parse error: ${err.message}`);
                    return;
                }
            }

            // Render the diagram
            const id = `mermaid-svg-${Date.now()}`;
            window.mermaid.render(id, diagramSource)
                .then(result => {
                    setSafeSVG(result.svg);
                    if (typeof result.bindFunctions === 'function') {
                        result.bindFunctions(output);
                    }
                    // Hide loading indicator after diagram is successfully rendered
                    window.hideLoadingIndicator();
                })
                .catch(e => {
                    showError(e.message);
                });
        };

        window.clearOutput = () => {
            const output = document.getElementById('output');
            if (output) {
                output.innerHTML = '';
            }
        };

        // Export functionality
        window.exportDiagram = {
        getSVG: () => {
            try {
                const svg = document.querySelector('#output svg');
                if (!svg) {
                    console.error('No SVG found in output');
                    return null;
                }

                // Clone to avoid modifying the original
                const clone = svg.cloneNode(true);

                // Ensure SVG has proper namespace
                clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

                // Get computed styles and inline them
                const inlineStyles = (element) => {
                    const styles = window.getComputedStyle(element);
                    let styleStr = '';

                    // Important SVG properties to inline
                    inlineStyleSVGProps.forEach(prop => {
                        const value = styles.getPropertyValue(prop);
                        if (value && value !== 'none' && value !== 'auto') {
                            styleStr += `${prop}:${value};`;
                        }
                    });

                    if (styleStr) {
                        element.setAttribute('style', styleStr);
                    }

                    // Recursively process children
                    Array.from(element.children).forEach(child => inlineStyles(child));
                };

                inlineStyles(clone);

                // Serialize to string
                const serializer = new XMLSerializer();
                return serializer.serializeToString(clone);
            } catch (error) {
                console.error('Error getting SVG:', error);
                return null;
            }
        },

        getPNG: async (scale = 2) => {
            try {
                const svg = document.querySelector('#output svg');
                if (!svg) {
                    console.error('No SVG found in output');
                    return null;
                }

                // Get SVG dimensions
                const bbox = svg.getBoundingClientRect();
                const width = bbox.width || 800;
                const height = bbox.height || 600;

                // Create canvas with scale factor
                const canvas = document.createElement('canvas');
                canvas.width = width * scale;
                canvas.height = height * scale;

                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);

                // Set background if not transparent
                const bgColor = window.exportDiagram.backgroundColor || 'white';
                if (bgColor !== 'transparent') {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, width, height);
                }

                // Convert SVG to image
                const svgData = window.exportDiagram.getSVG();
                if (!svgData) return null;

                const img = new Image();
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        try {
                            ctx.drawImage(img, 0, 0, width, height);
                            URL.revokeObjectURL(url);

                            // Convert to base64
                            canvas.toBlob((blob) => {
                                if (!blob) {
                                    reject(new Error('Failed to create blob'));
                                    return;
                                }

                                const reader = new FileReader();
                                reader.onloadend = () => {
                                    // Return base64 without data URL prefix
                                    const base64 = reader.result.split(',')[1];
                                    resolve(base64);
                                };
                                reader.onerror = reject;
                                reader.readAsDataURL(blob);
                            }, 'image/png');
                        } catch (error) {
                            URL.revokeObjectURL(url);
                            reject(error);
                        }
                    };

                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load SVG as image'));
                    };

                    img.src = url;
                });
            } catch (error) {
                console.error('Error creating PNG:', error);
                return null;
            }
        },

        // Configuration properties
        backgroundColor: 'white'
      };
  </script>
</head>
<body>
  <div id="loading-container">
    <div class="spinner"></div>
    <div id="loading-status">Initializing...</div>
  </div>
  <div id="output"></div>
</body>
</html>