<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:;" />
  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MermaidPad Preview</title>
  <style>
    /* Paint correctly on first frame based on OS theme */
    html, body {
      margin: 0;
      height: 100%;
      background: #fff;
      color: #222;
    }

    @media (prefers-color-scheme: dark) {
      html, body {
        background: #1e1e1e;
        color: #ddd;
      }
    }

    body.dark-theme {
      background: #000;
      color: #ddd;
    }

    body.light-theme {
      background: #fff;
      color: #222;
    }

    /* CSS custom property for transition duration */
    :root {
      --loading-transition-duration: 300ms;
    }

    #output {
      padding: 8px;
      overflow: hidden;
      width: 100vw; /*fill viewport width*/
      height: 100vh; /*fill viewport height*/
      box-sizing: border-box;
      display: none;
      background-color: yellow; /* TEMP debugging - remove this line when done*/
      position: fixed; /* changed from 'relative' - stay fixed to viewport */
      top: 0;
      left: 0;
    }

    #output.visible {
      display: block;
    }

    .error {
      color: #ff6f6f;
      white-space: pre;
      font-family: Consolas,monospace;
    }

    /* Loading indicator styles */
    #loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      transition: opacity var(--loading-transition-duration) ease-out, visibility 0s ease-out var(--loading-transition-duration);
    }

      #loading-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

    .spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 0.1875rem solid rgba(0, 0, 0, 0.1);
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spinner-rotate 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    body.dark-theme .spinner {
      border-color: rgba(255, 255, 255, 0.1);
      border-top-color: #4db8ff;
    }

    #loading-container.hidden .spinner {
      animation: none;
    }

    @keyframes spinner-rotate {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loading-status {
      position: absolute;
      top: calc(50% + 3rem);
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 1rem;
      color: #666;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      white-space: nowrap;
      will-change: transform;
    }

    body.dark-theme #loading-status {
      color: #aaa;
    }

    /* Mermaid dark theme overrides */
    body.dark-theme #output svg .messageLine,
    body.dark-theme #output svg .actor-line,
    body.dark-theme #output svg .mermaid .edgePath path,
    body.dark-theme #output svg .mermaid .node rect,
    body.dark-theme #output svg .mermaid .node circle,
    body.dark-theme #output svg .mermaid .node ellipse {
      stroke: #e0e0e0 !important;
    }

    body.dark-theme #output svg text,
    body.dark-theme #output svg .messageText {
      fill: #e0e0e0 !important;
    }

    /* ============================================
    HOVER HIGHLIGHTING STYLES FOR MERMAID DIAGRAMS
    ============================================ */

    /* Enable smooth transitions for all interactive elements */
    #output svg .node,
    #output svg .edgePath path,
    #output svg .flowchart-link,
    #output svg .actor,
    #output svg .activation,
    #output svg rect,
    #output svg circle,
    #output svg ellipse,
    #output svg polygon,
    #output svg path,
    #output svg .messageText,
    #output svg .labelText,
    #output svg .nodeLabel,
    #output svg .edgeLabel {
      transition: all 0.2s ease-in-out;
      cursor: inherit; /*changed from 'pointer' to allow panzoom cursor*/
    }

    /* ============================================
    LIGHT THEME HOVER EFFECTS
    ============================================ */

    /* Node hover effects - Light theme */
    body.light-theme #output svg .node:hover rect,
    body.light-theme #output svg .node:hover circle,
    body.light-theme #output svg .node:hover ellipse,
    body.light-theme #output svg .node:hover polygon {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* Node label hover - Light theme */
    body.light-theme #output svg .node:hover .nodeLabel,
    body.light-theme #output svg .node:hover text {
      font-weight: 600 !important;
      fill: #005a9e !important;
    }

    /* Edge/Path hover effects - Light theme */
    body.light-theme #output svg .edgePath:hover path,
    body.light-theme #output svg .flowchart-link:hover {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    /* Edge label hover - Light theme */
    body.light-theme #output svg .edgeLabel:hover,
    body.light-theme #output svg .edgeLabel:hover text {
      fill: #005a9e !important;
      font-weight: 600 !important;
    }

    /* Sequence diagram specific - Light theme */
    body.light-theme #output svg .actor:hover rect,
    body.light-theme #output svg .actor:hover circle {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    body.light-theme #output svg .activation:hover rect {
      fill: #cce5ff !important;
      stroke: #007acc !important;
      stroke-width: 2px !important;
    }

    body.light-theme #output svg .messageLine:hover {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    /* Class diagram specific - Light theme */
    body.light-theme #output svg .classGroup:hover rect {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* State diagram specific - Light theme */
    body.light-theme #output svg .stateGroup:hover rect,
    body.light-theme #output svg .stateGroup:hover circle {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* ============================================
    DARK THEME HOVER EFFECTS
    ============================================ */

    /* Node hover effects - Dark theme */
    body.dark-theme #output svg .node:hover rect,
    body.dark-theme #output svg .node:hover circle,
    body.dark-theme #output svg .node:hover ellipse,
    body.dark-theme #output svg .node:hover polygon {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* Node label hover - Dark theme */
    body.dark-theme #output svg .node:hover .nodeLabel,
    body.dark-theme #output svg .node:hover text {
      font-weight: 600 !important;
      fill: #ffffff !important;
      filter: drop-shadow(0 0 4px rgba(77, 184, 255, 0.8));
    }

    /* Edge/Path hover effects - Dark theme */
    body.dark-theme #output svg .edgePath:hover path,
    body.dark-theme #output svg .flowchart-link:hover {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    /* Edge label hover - Dark theme */
    body.dark-theme #output svg .edgeLabel:hover,
    body.dark-theme #output svg .edgeLabel:hover text {
      fill: #ffffff !important;
      font-weight: 600 !important;
      filter: drop-shadow(0 0 4px rgba(77, 184, 255, 0.8));
    }

    /* Sequence diagram specific - Dark theme */
    body.dark-theme #output svg .actor:hover rect,
    body.dark-theme #output svg .actor:hover circle {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    body.dark-theme #output svg .activation:hover rect {
      fill: #1a4d6b !important;
      stroke: #4db8ff !important;
      stroke-width: 2px !important;
    }

    body.dark-theme #output svg .messageLine:hover {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
      filter: drop-shadow(0 0 6px rgba(77, 184, 255, 0.5));
    }

    /* Class diagram specific - Dark theme */
    body.dark-theme #output svg .classGroup:hover rect {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* State diagram specific - Dark theme */
    body.dark-theme #output svg .stateGroup:hover rect,
    body.dark-theme #output svg .stateGroup:hover circle {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* ============================================
    ADDITIONAL HOVER ENHANCEMENTS
    ============================================ */

    /* Pie chart segments */
    body.light-theme #output svg .pieCircle:hover {
      filter: brightness(1.2) drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
      transform: scale(1.05);
      transform-origin: center;
    }

    body.dark-theme #output svg .pieCircle:hover {
      filter: brightness(1.3) drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
      transform: scale(1.05);
      transform-origin: center;
    }

    /* Gantt chart bars */
    body.light-theme #output svg .task:hover {
      filter: brightness(1.15) drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    body.dark-theme #output svg .task:hover {
      filter: brightness(1.25) drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    /* Generic rect elements (fallback for all diagram types) */
    body.light-theme #output svg rect:hover {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    body.dark-theme #output svg rect:hover {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
    }

    /* Improve hover cursor for all interactive elements */
    #output svg .node,
    #output svg .edgePath,
    #output svg .actor,
    #output svg .classGroup,
    #output svg .stateGroup,
    #output svg .task,
    #output svg .pieCircle {
      cursor: pointer;
    }

    /* Prevent text selection during hover interactions */
    #output svg text {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* ============================================
    CLASS-BASED HOVER EFFECTS (for JavaScript-triggered hovers)
    Mirror the :hover rules above for .hover-active class.

    Why both :hover and .hover-active?
      The :hover pseudo-class handles direct pointer hovers on elements,
      providing immediate visual feedback when the user hovers over an element.
      The .hover-active class is applied via JavaScript to enable hover effects
      on elements that may not be directly hovered (e.g., hit areas, accessibility
      features, or programmatic interactions). This ensures consistent hover
      styling whether triggered by pointer events or by script.
    ============================================ */

    /* Light theme - class-based hover for paths/edges */
    body.light-theme #output svg path.hover-active,
    body.light-theme #output svg .edgePath path.hover-active,
    body.light-theme #output svg .flowchart-link.hover-active {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    body.light-theme #output svg line.hover-active,
    body.light-theme #output svg .messageLine.hover-active {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    /* Dark theme - class-based hover for paths/edges */
    body.dark-theme #output svg path.hover-active,
    body.dark-theme #output svg .edgePath path.hover-active,
    body.dark-theme #output svg .flowchart-link.hover-active {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    body.dark-theme #output svg line.hover-active,
    body.dark-theme #output svg .messageLine.hover-active {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
      filter: drop-shadow(0 0 6px rgba(77, 184, 255, 0.5));
    }

    /* ============================================
    FLOATING ZOOM TOOLBAR STYLES FOR PAN/ZOOM FEATURE
    ============================================ */
    #zoom-toolbar {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.75);
      border-radius: 8px;
      padding: 8px;
      padding-top: 12px; /*space at top for dragging*/
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      transition: opacity 0.2s ease-in-out;
      user-select: none;
      cursor: grab;
    }

    body.light-theme #zoom-toolbar {
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    #zoom-toolbar.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .zoom-button {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease-in-out;
      white-space: nowrap;
    }

    body.light-theme .zoom-button {
      background: rgba(0, 0, 0, 0.05);
      border-color: rgba(0, 0, 0, 0.15);
      color: #333;
    }

    .zoom-button:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateX(-2px);
    }

    body.light-theme .zoom-button:hover {
      background: rgba(0, 0, 0, 0.1);
      border-color: rgba(0, 0, 0, 0.3);
    }

    .zoom-button:active {
      transform: translateX(-2px) scale(0.95);
    }

    .zoom-button-icon {
      font-size: 16px;
      line-height: 1;
    }

    #zoom-level-display {
      text-align: center;
      padding: 8px 12px;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      margin-top: 4px;
    }

    body.light-theme #zoom-level-display {
      color: #333;
      border-top-color: rgba(0, 0, 0, 0.15);
    }
  </style>
  <!-- Apply theme immediately before any scripts load -->
  <script>
    // Immediate theme application to prevent flash
    (function () {
      const getSystemTheme = () => {
        if (globalThis.matchMedia && globalThis.matchMedia('(prefers-color-scheme: dark)').media !== 'not all') {
          return globalThis.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        }
        return 'default';
      };

      const applyTheme = theme => {
        document.body.classList.toggle('dark-theme', theme === 'dark');
        document.body.classList.toggle('light-theme', theme === 'default');
      };

      // Store functions globally for reuse
      globalThis.getSystemTheme = getSystemTheme;
      globalThis.applyTheme = applyTheme;
      globalThis.currentTheme = getSystemTheme();

      // Apply theme immediately if body exists
      if (document.body) {
        applyTheme(globalThis.currentTheme);
      } else {
        // If body doesn't exist yet, apply on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function () {
          applyTheme(globalThis.currentTheme);
        }, { once: true });
      }
    })();
  </script>

  <!-- Load js-yaml first, no defer to avoid races -->
  <script src="js-yaml.min.js" id="jsyaml-script"></script>

  <!-- Load Mermaid, no defer to avoid races -->
  <script src="mermaid.min.js" id="mermaid-script"></script>

  <!-- Load Panzoom, no defer to avoid races -->
  <script src="panzoom.min.js" id="panzoom-script"></script>

  <!-- Main initialization with proper event-driven loading -->
  <script type="module">
    // Global flags
    globalThis.elkLayoutAvailable = false;
    globalThis.mermaidInitialized = false;

    // Promise-based script loading with timeout
    function waitForScriptLoad(scriptId, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const script = document.getElementById(scriptId);

        if (!script) {
          reject(new Error(`Script element with id '${scriptId}' not found`));
          return;
        }

        // Check if already loaded
        if (scriptId === 'mermaid-script' && globalThis.mermaid !== undefined) {
          resolve();
          return;
        }
        if (scriptId === 'jsyaml-script' && globalThis.jsyaml !== undefined) {
          resolve();
          return;
        }

        // Set up timeout
        const timeoutId = setTimeout(() => {
          reject(new Error(`Script '${scriptId}' load timeout after ${timeout}ms`));
        }, timeout);

        // Set up load event listener
        const handleLoad = () => {
          clearTimeout(timeoutId);
          resolve();
        };

        const handleError = (error) => {
          clearTimeout(timeoutId);
          reject(new Error(`Script '${scriptId}' failed to load: ${error.message || 'Unknown error'}`));
        };

        script.addEventListener('load', handleLoad, { once: true });
        script.addEventListener('error', handleError, { once: true });
      });
    }

    // Load ELK layout module
    async function loadElkLayout() {
      try {
        const elkModule = await import('./mermaid-elk-layout/mermaid-layout-elk.esm.min.mjs');
        const elkLayouts = elkModule.default;

        // Register ELK layouts with Mermaid
        globalThis.mermaid.registerLayoutLoaders(elkLayouts);
        globalThis.elkLayoutAvailable = true;
        console.log('ELK layout registered successfully');
        return true;
      } catch (err) {
        console.error('Failed to load ELK layout:', err);
        console.log('Continuing without ELK layout support');
        return false;
      }
    }

    // Main initialization function (call-site uses suppressHideLoadingIndicator: true)
    async function initializeApplication() {
      try {
        // Wait for both scripts to load
        console.log('Waiting for scripts to load...');
        await Promise.all([
          waitForScriptLoad('jsyaml-script'),
          waitForScriptLoad('mermaid-script')
        ]);

        console.log('Scripts loaded, initializing Mermaid...');

        // Update loading status
        globalThis.updateLoadingStatus('Loading rendering engine...');

        // Try to load ELK layout
        await loadElkLayout();

        // Initialize mermaid (with or without ELK)
        globalThis.mermaid.initialize({
          startOnLoad: false,
          theme: globalThis.currentTheme
        });

        // Set initialization flag
        globalThis.mermaidInitialized = true;
        console.log('Mermaid initialized successfully');

        // Process any pending render without impacting init state
        if (globalThis.pendingMermaidRender) {
          console.log('Processing pending render...');
          try {
            // Tell renderMermaid to NOT hide the loading indicator (init owns it)
            const renderResult = await globalThis.renderMermaid(globalThis.pendingMermaidRender, { suppressHideLoadingIndicator: true });
            if (!renderResult?.success) {
              // Error already rendered by renderMermaid; just log.
              console.warn('Pending render failed.');
            }
          } catch (renderError) {
            // Guard: renderMermaid should return a result rather than throw, but protect anyway.
            console.error('Failed to render Mermaid diagram:', renderError);
          } finally {
            globalThis.pendingMermaidRender = null;
          }
        }
      } catch (error) {
        console.error('Failed to initialize application:', error);
        // Set flag to prevent infinite retries (this is for init failures only)
        globalThis.mermaidInitializationFailed = true;

        const output = document.getElementById('output');
        if (output) {
          output.classList.add('visible');
          output.innerHTML = `<div class="error">Failed to initialize: ${error.message}</div>`;
        }
      } finally {
        // Always hide the loading indicator after all initialization and any pending render
        console.log('Initialization complete, hiding loading indicator.');
        globalThis.hideLoadingIndicator();
      }
    }

    // Start initialization - use top-level await (module)
    try {
      await initializeApplication();
    } catch (err) {
      console.error('initializeApplication failed:', err);
    }

    // Setup theme change listener
    document.addEventListener('DOMContentLoaded', () => {
      // Theme is already applied, but listen for changes
      if (globalThis.matchMedia) {
        globalThis.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
          globalThis.currentTheme = e.matches ? 'dark' : 'default';
          globalThis.applyTheme(globalThis.currentTheme);

          // Re-render if we have content and Mermaid is initialized
          if (globalThis.lastMermaidSource && globalThis.mermaidInitialized) {
            // Re-initialize Mermaid with new theme
            globalThis.mermaid.initialize({
              startOnLoad: false,
              theme: globalThis.currentTheme
            });
            globalThis.renderMermaid(globalThis.lastMermaidSource);
          }
        });
      }
    });
  </script>
  <!-- Render functions in separate script -->
  <script>
    // Get transition duration from CSS custom property
    const getTransitionDuration = () => {
      const duration = getComputedStyle(document.documentElement)
        .getPropertyValue('--loading-transition-duration')
        .trim();
      // Remove 'ms' suffix and convert to number
      const numericValue = Number.parseFloat(duration.replace('ms', ''));
      return Number.isNaN(numericValue) ? 300 : numericValue; // Fallback to 300ms if parsing fails
    };

    // Loading indicator management
    globalThis.updateLoadingStatus = (message) => {
      const statusElement = document.getElementById('loading-status');
      if (statusElement) {
        statusElement.textContent = message;
      }
    };

    globalThis.hideLoadingIndicator = () => {
      const loadingContainer = document.getElementById('loading-container');
      const output = document.getElementById('output');

      if (loadingContainer) {
        loadingContainer.classList.add('hidden');
        // Remove from DOM after transition completes (duration from CSS variable)
        setTimeout(() => {
          loadingContainer.style.display = 'none';
        }, getTransitionDuration());
      }

      if (output) {
        output.classList.add('visible');
      }

      try {
        // Set the flag for C# polling (AvaloniaWebView doesn't support postMessage events)
        globalThis.__renderingComplete__ = true;
        console.log('Set __renderingComplete__ flag for C# polling');

        // Try platform-specific notifications

        // Try WebView2 (Windows) - check existence on globalThis to avoid implicit declaration warning
        if (globalThis.chrome && globalThis.chrome.webview && globalThis.chrome.webview.postMessage) {
          try {
            globalThis.chrome.webview.postMessage('renderingComplete');
            console.log('Sent postMessage via chrome.webview (may not be received by AvaloniaWebView)');
          } catch (chromeError) {
            // Silently ignore - AvaloniaWebView may not support this
            console.debug('chrome.webview.postMessage failed:', chromeError.message);
          }
        }

        // Try WebKit (macOS/Linux) - check existence on globalThis to avoid implicit declaration warning
        if (globalThis.webkit && globalThis.webkit.messageHandlers && globalThis.webkit.messageHandlers.renderingComplete) {
          try {
            globalThis.webkit.messageHandlers.renderingComplete.postMessage('');
            console.log('Sent postMessage via webkit.messageHandlers (may not be received by AvaloniaWebView)');
          } catch (webkitError) {
            // Silently ignore - AvaloniaWebView may not support this
            console.debug('webkit.messageHandlers failed:', webkitError.message);
          }
        }
      } catch (outerError) {
        // Even if postMessage fails, ensure the flag is set
        console.error('Error in render completion notification:', outerError.message);
        globalThis.__renderingComplete__ = true;
      }
    };

    // Render function with proper error handling
    // signature: renderMermaid(source, options = { suppressHideLoadingIndicator: false })
    globalThis.renderMermaid = async (source, options = {}) => {
      const suppressHide = !!options.suppressHideLoadingIndicator;
      globalThis.lastMermaidSource = source; // Save for re-rendering
      const output = document.getElementById('output');

      // Helper functions
      const createErrorElement = (message) => {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.textContent = message; // XSS-safe
        return errorDiv;
      };

      const showError = (message) => {
        // Render error into output; hide loader only if caller did not suppress it.
        if (output) {
          output.innerHTML = '';
          output.appendChild(createErrorElement(message));
        }
        if (!suppressHide) {
          try {
            globalThis.hideLoadingIndicator();
          } catch (e) {
            console.error('Error hiding loading indicator:', e);
          }
        }
      };

      // ReSharper disable once InconsistentNaming
      // Replace the entire renderMermaid setSafeSVG section (around line 778):
      const setSafeSVG = (htmlContent) => {
        const trimmed = htmlContent.trim();
        if (trimmed.startsWith('<svg') && trimmed.includes('</svg>')) {
          if (output) {
            output.innerHTML = htmlContent;  // NO wrapper - back to original
          }
          // Enhance hover interactivity after SVG is rendered
          if (typeof globalThis.enhanceHoverability === 'function') {
            const hoverActivationDelay = globalThis.elkLayoutAvailable ? 200 : 50;
            setTimeout(() => globalThis.enhanceHoverability(), hoverActivationDelay);
          }
          // Initialize pan/zoom after SVG is rendered (only if not already initialized)
          if (typeof globalThis.initializePanZoom === 'function') {
            if (!globalThis.panzoomInstance) {
              console.log('First render - initializing pan/zoom');
              globalThis.initializePanZoom();
            } else {
              console.log('Pan/zoom already initialized - skipping re-init');
            }
          }
        } else {
          showError('Invalid diagram content received');
        }
      };

      // Check if initialization failed
      if (globalThis.mermaidInitializationFailed) {
        showError('Mermaid initialization failed. Please refresh the page.');
        return { success: false, error: 'Initialization failed' };
      }

      // Check if mermaid is initialized
      if (!globalThis.mermaidInitialized) {
        // Store for later rendering
        globalThis.pendingMermaidRender = source;

        // Retry logic (same behavior, but return a result)
        if (!globalThis.renderRetryCount) {
          globalThis.renderRetryCount = 0;
        }

        if (globalThis.renderRetryCount < 10) {
          globalThis.renderRetryCount++;
          setTimeout(() => globalThis.renderMermaid(source, options), 200);
          return { success: false, error: 'Mermaid is initializing; retry scheduled' };
        } else {
          try {
            showError('Mermaid is still loading. Please try again.');
            return { success: false, error: 'Mermaid loading timeout' };
          } finally {
            // Ensure retry count is reset even if showError throws
            globalThis.renderRetryCount = 0;
          }
        }
      }

      // Reset retry count on successful initialization path
      globalThis.renderRetryCount = 0;

      // Parse front-matter config if present
      const fmRegex = /^---\s*([\s\S]*?)---\s*/;
      let diagramSource = source;
      const match = source.match(fmRegex);

      if (match) {
        try {
          const parsed = globalThis.jsyaml.load(match[1]);
          if (parsed && parsed.config) {
            const customConfig = parsed.config;

            // Re-initialize with new config
            const configWithTheme = {
              ...customConfig,
              theme: customConfig.theme || globalThis.currentTheme,
              startOnLoad: false
            };

            // Log config for debugging if using ELK
            if (globalThis.elkLayoutAvailable && customConfig.flowchart?.defaultRenderer === 'elk') {
              console.log('Using ELK layout with config:', configWithTheme);
            }

            globalThis.mermaid.initialize(configWithTheme);
          }
          // Remove front-matter from diagram source
          diagramSource = source.replace(fmRegex, "");
        } catch (err) {
          showError(`YAML parse error: ${err.message}`);
          return { success: false, error: `YAML parse error: ${err.message}` };
        }
      }

      // Render the diagram
      const id = `mermaid-svg-${Date.now()}`;
      try {
        const result = await globalThis.mermaid.render(id, diagramSource);
        setSafeSVG(result.svg);
        if (typeof result.bindFunctions === 'function') {
          result.bindFunctions(output);
        }
        // Hide loader for normal renders (unless caller suppressed)
        if (!suppressHide) {
          try {
            globalThis.hideLoadingIndicator();
          } catch (e) {
            console.error('Error hiding loading indicator', e);
          }
        }
        return { success: true };
      } catch (e) {
        showError(e.message);
        // Do NOT rethrow; return a failure result to avoid leaking into init failure path
        return { success: false, error: e.message };
      }
    };

    globalThis.clearOutput = () => {
      const output = document.getElementById('output');
      if (output) {
        output.innerHTML = '';
      }
    };

    // ==========================================
    // BROWSER-BASED PNG EXPORT FUNCTION
    // Renders the current diagram to PNG using canvas
    // ==========================================
    globalThis.exportToPNG = async function (options) {
      console.log('Browser-based PNG export started');
      console.log('Export options:', options);

      // Helper to set status and notify host (if available)
      const setExportStatus = (statusObj) => {
        try {
          const json = JSON.stringify(statusObj);
          globalThis.__pngExportStatus__ = json;

          // Prefer WebView2 style postMessage (safe check using globalThis)
          const webviewPostMessage = globalThis.chrome?.webview?.postMessage;
          if (typeof webviewPostMessage === 'function') {
            try {
              webviewPostMessage({ type: 'png-export-progress', status: statusObj });
            } catch (postError) {
              console.warn('chrome.webview.postMessage failed', postError);
            }
            return;
          }

          // Fallback for other hosts - window.external may be deprecated but check safely on globalThis
          const externalNotify = globalThis.external?.notify;
          if (typeof externalNotify === 'function') {
            try {
              externalNotify(JSON.stringify({ type: 'png-export-progress', status: statusObj }));
            } catch (exportProgressError) {
              console.warn('external.notify failed', exportProgressError);
            }
          }
        } catch (statusError) {
          // Ignore status delivery errors - keep working locally
          console.warn('Failed to set or notify export status', statusError);
        }
      };

      try {
        // Set status for polling
        setExportStatus({
          step: 'initializing',
          percent: 0,
          message: 'Starting PNG export...'
        });

        // Validate we have diagram source
        if (!globalThis.lastMermaidSource) {
          throw new Error('No diagram source available for export');
        }

        // Parse options with defaults
        const scale = options?.scale || 2;
        const backgroundColor = options?.backgroundColor || 'white';
        const dpi = options?.dpi || 96;

        // Calculate DPI scale (96 is the baseline DPI)
        const dpiScale = dpi / 96;
        const effectiveScale = scale * dpiScale;

        console.log(`Using scale: ${scale}, DPI: ${dpi}, effective scale: ${effectiveScale}`);

        // Update progress: Rendering
        setExportStatus({
          step: 'rendering',
          percent: 20,
          message: 'Rendering diagram...'
        });

        // Render fresh SVG with current config
        const id = `png-export-${Date.now()}`;
        const renderResult = await globalThis.mermaid.render(id, globalThis.lastMermaidSource);

        if (!renderResult?.svg) {
          throw new Error('Failed to render diagram for PNG export');
        }

        // Update progress: Creating canvas
        setExportStatus({
          step: 'creating-canvas',
          percent: 40,
          message: 'Creating canvas...'
        });

        // Create temporary container for SVG
        const container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.left = '-99999px';
        container.style.top = '-99999px';
        container.innerHTML = renderResult.svg;
        document.body.appendChild(container);

        const svgElement = container.querySelector('svg');
        if (!svgElement) {
          container.remove();
          throw new Error('Could not find SVG element in rendered output');
        }

        // Get dimensions from viewBox or bounding box
        const viewBox = svgElement.getAttribute('viewBox');
        let width, height;

        if (viewBox) {
          const parts = viewBox.split(' ');
          width = Number.parseFloat(parts[2]);
          height = Number.parseFloat(parts[3]);
        } else {
          const bbox = svgElement.getBoundingClientRect();
          width = bbox.width || 800;
          height = bbox.height || 600;
        }

        const scaledWidth = Math.round(width * effectiveScale);
        const scaledHeight = Math.round(height * effectiveScale);
        const totalPixels = scaledWidth * scaledHeight;
        const estimatedMemoryMB = (totalPixels * 4) / (1024 * 1024); // 4 bytes per pixel

        console.log(`SVG dimensions: ${width}x${height}, scaled: ${scaledWidth}x${scaledHeight}`);
        console.log(`Total pixels: ${totalPixels.toLocaleString()}, estimated memory: ${estimatedMemoryMB.toFixed(0)} MB`);

        // Validate canvas size limits
        const maxDimension = 32767; // Browser spec limit per dimension
        const maxPixels = 16384 * 16384; // 16384 x 16384 = 256M pixels (practical limit)
        const maxMemoryMB = 1024; // 1 GB practical memory limit

        if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
          container.remove();
          throw new Error(`Canvas dimension exceeds browser limit of ${maxDimension} pixels. Current: ${scaledWidth}x${scaledHeight}. Try reducing scale or DPI.`);
        }

        if (totalPixels > maxPixels) {
          container.remove();
          const oneMillion = 1000000;
          throw new Error(`Canvas size too large (${(totalPixels / oneMillion).toFixed(1)}M pixels). Maximum recommended: ${(maxPixels / oneMillion).toFixed(0)}M pixels. Try reducing scale or DPI.`);
        }

        if (estimatedMemoryMB > maxMemoryMB) {
          container.remove();
          throw new Error(`Estimated memory usage (${estimatedMemoryMB.toFixed(0)} MB) exceeds safe limit of ${maxMemoryMB} MB. Try reducing scale or DPI.`);
        }

        // Update progress: Converting to bitmap
        setExportStatus({
          step: 'converting',
          percent: 60,
          message: 'Converting to bitmap...'
        });

        // Create canvas with scaled dimensions
        const canvas = document.createElement('canvas');
        canvas.width = scaledWidth;
        canvas.height = scaledHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          container.remove();
          throw new Error('Failed to get canvas 2D context');
        }

        // Scale context for high-DPI rendering
        ctx.scale(effectiveScale, effectiveScale);

        // Draw background if not transparent
        if (backgroundColor && backgroundColor.toLowerCase() !== 'transparent') {
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(0, 0, width, height);
        }

        // Serialize SVG to string
        const svgString = new XMLSerializer().serializeToString(svgElement);

        // Clean up DOM
        container.remove();

        // Convert SVG to data URI (avoids canvas tainting issues with blob URLs)
        // Encode the SVG string properly for data URI
        const encodedSvg = encodeURIComponent(svgString)
          .replaceAll('\'', '%27')
          .replaceAll('"', '%22');

        const dataUri = `data:image/svg+xml;charset=utf-8,${encodedSvg}`;

        // Load SVG into image
        const img = new Image();

        // Create promise for image loading
        const imageLoadPromise = new Promise((resolve, reject) => {
          img.onload = () => {
            resolve();
          };

          img.onerror = (error) => {
            reject(new Error(`Failed to load SVG as image: ${error}`));
          };

          // Set timeout for image loading (30 seconds)
          setTimeout(() => {
            reject(new Error('Image loading timeout'));
          }, 30000);
        });

        img.src = dataUri;
        await imageLoadPromise;

        // Update progress: Drawing to canvas
        setExportStatus({
          step: 'drawing',
          percent: 80,
          message: 'Drawing to canvas...'
        });

        // Draw image to canvas
        ctx.drawImage(img, 0, 0, width, height);

        // Update progress: Encoding
        setExportStatus({
          step: 'encoding',
          percent: 90,
          message: 'Encoding PNG...'
        });

        // Convert canvas to PNG data URL
        const dataUrl = canvas.toDataURL('image/png');

        // Validate that toDataURL() succeeded
        // Some browsers return 'data:,' if canvas.toDataURL() fails (e.g., canvas is empty, too large, or encoding error)
        if (!dataUrl || dataUrl === 'data:,' || !dataUrl.includes(',')) {
          throw new Error('Failed to encode canvas to PNG. The canvas size may be too large for this browser. Try reducing scale or DPI.');
        }

        // Extract base64 data (remove "data:image/png;base64," prefix)
        const base64Data = dataUrl.split(',')[1];

        // Validate base64 data
        if (!base64Data || base64Data.length === 0) {
          throw new Error('PNG encoding produced empty data. Try reducing scale or DPI.');
        }

        // Update progress: Complete
        setExportStatus({
          step: 'complete',
          percent: 100,
          message: 'Export complete!'
        });

        console.log('PNG export successful, data length:', base64Data.length);

        // Store result for retrieval
        globalThis.__pngExportResult__ = base64Data;

        // Notify host that result is available (lightweight notification)
        try {
          const webviewPostMessage = globalThis.chrome?.webview?.postMessage;
          if (typeof webviewPostMessage === 'function') {
            webviewPostMessage({ type: 'png-export-complete', length: base64Data.length });
          } else {
            const externalNotify = globalThis.external?.notify;
            if (typeof externalNotify === 'function') {
              externalNotify(JSON.stringify({ type: 'png-export-complete', length: base64Data.length }));
            }
          }
        } catch (e) {
          // log notification errors
          console.error('Error notifying host that result is available', e);
        }

        return {
          success: true,
          dataLength: base64Data.length,
          dimensions: { width: canvas.width, height: canvas.height }
        };

      } catch (error) {
        console.error('PNG export failed:', error);

        setExportStatus({
          step: 'error',
          percent: 0,
          message: error.message
        });

        globalThis.__pngExportResult__ = null;

        return {
          success: false,
          error: error.message
        };
      }
    };

    console.log('Browser-based PNG export function registered: globalThis.exportToPNG');

    // Legacy export functions (kept for compatibility)
    globalThis.exportDiagram = {
      getSVG: () => {
        try {
          const svg = document.querySelector('#output svg');
          if (!svg) {
            console.error('No SVG found in output');
            return null;
          }

          // Clone and ensure proper attributes
          const clone = svg.cloneNode(true);
          clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

          // Mermaid already includes styles, just serialize
          return new XMLSerializer().serializeToString(clone);
        } catch (error) {
          console.error('Error getting SVG:', error);
          return null;
        }
      }
    };

    // ==========================================
    // HOVER ENHANCEMENT FUNCTION
    // Adds invisible wider hit areas to paths/lines for easier hovering
    // Uses a single delegated event listener to avoid memory leaks
    // Uses event delegation on OUTPUT container (persists across renders)
    // Hit areas are recreated on each render (inside SVG which gets replaced)
    // ==========================================
    globalThis.enhanceHoverability = function () {
      const hitAreaWidth = 20; // Adjustable hover detection width in pixels
      const output = document.getElementById('output');
      if (!output) return;

      const svg = output.querySelector('svg');
      if (!svg) return;

      // Check if event delegation is already initialized on OUTPUT container
      // (OUTPUT persists across renders, unlike SVG which gets replaced)
      const isInitialized = !!output.dataset.hoverDelegationInit;

      // Find all paths and lines that need hit areas
      const paths = svg.querySelectorAll('path.flowchart-link, .edgePath path, path[class*="edge"], path[marker-end]');
      const lines = svg.querySelectorAll('line.messageLine, line[class*="edge"], line[marker-end]');

      // Create hit areas for paths (these get recreated on each render since SVG is replaced)
      for (const path of paths) {
        if (path.dataset.hoverEnhanced) {
          console.debug('Skipping already-enhanced path', path);
          continue;
        }
        const hitArea = path.cloneNode(false);
        hitArea.classList.add('hit-area');
        hitArea.dataset.hoverEnhanced = 'true';
        hitArea.style.strokeWidth = `${hitAreaWidth}px`;
        hitArea.style.stroke = 'transparent';
        hitArea.style.fill = 'none';
        hitArea.style.pointerEvents = 'stroke';
        hitArea.style.cursor = 'inherit'; /*changed from 'pointer' to allow panzoom cursor*/

        // Insert the hit area immediately after the original path (stable sibling relationship)
        path.parentNode.insertBefore(hitArea, path.nextSibling);
        path.dataset.hoverEnhanced = 'true';
        path.dataset.hoverTarget = 'true';
      }

      // Create hit areas for lines
      for (const line of lines) {
        if (line.dataset.hoverEnhanced) {
          console.debug('Skipping already-enhanced line', line);
          continue;
        }

        const hitArea = line.cloneNode(false);
        hitArea.classList.add('hit-area');
        hitArea.dataset.hoverEnhanced = 'true';
        hitArea.style.strokeWidth = `${hitAreaWidth}px`;
        hitArea.style.stroke = 'transparent';
        hitArea.style.pointerEvents = 'stroke';
        hitArea.style.cursor = 'inherit'; /*changed from 'pointer' to allow panzoom cursor*/

        // Insert the hit area immediately after the original line (stable sibling relationship)
        line.parentNode.insertBefore(hitArea, line.nextSibling);
        line.dataset.hoverEnhanced = 'true';
        line.dataset.hoverTarget = 'true';
      }

      // Only attach event listeners ONCE to the OUTPUT container
      // These listeners persist across renders since OUTPUT doesn't get replaced
      if (!isInitialized) {
        // Use event delegation on OUTPUT container (not SVG which gets replaced)
        output.addEventListener('mouseover', (e) => {
          // Early exit: Skip if not hovering over SVG elements (performance optimization)
          if (!e.target.closest('svg')) return;

          const hitArea = e.target.closest('.hit-area');
          if (!hitArea) return;

          // Get original element via previousElementSibling (O(1) fast, stable in our architecture)
          // Safe because: hit area is inserted immediately after original, and SVG is replaced entirely on each render
          const original = hitArea.previousElementSibling;
          if (original?.dataset?.hoverTarget) {
            original.classList.add('hover-active');
          }
        }, { capture: true });

        output.addEventListener('mouseout', (e) => {
          // Early exit: Skip if not hovering over SVG elements (performance optimization)
          if (!e.target.closest('svg')) return;

          const hitArea = e.target.closest('.hit-area');
          if (!hitArea) return;

          // Check if we're actually leaving the hit-area, not just moving to a child element
          // relatedTarget is where the mouse is moving TO
          if (hitArea.contains(e.relatedTarget)) return;

          // Get original element via previousElementSibling (O(1) fast, stable in our architecture)
          // Safe because: hit area is inserted immediately after original, and SVG is replaced entirely on each render
          const original = hitArea.previousElementSibling;
          if (original?.dataset?.hoverTarget) {
            original.classList.remove('hover-active');
          }
        }, { capture: true });

        // Mark OUTPUT container as initialized (persists across SVG replacements)
        output.dataset.hoverDelegationInit = 'true';

        console.log('Hover event delegation initialized (one-time setup)');
      }

      // Log hit area creation on first render only (when event delegation is first initialized)
      if (!isInitialized && paths.length + lines.length > 0) {
        console.log(`Created hit areas for ${paths.length} paths and ${lines.length} lines`);
      }
    };

    // ==========================================
    // PANZOOM FUNCTIONALITY
    // Initializes pan/zoom on the output container. Preserves zoom/pan state across renders
    // ==========================================
    globalThis.panzoomInstance = null;
    globalThis.panzoomEventHandlers = null; // Store handlers for cleanup
    globalThis.panzoomInitializedOnce = false; // Track first initialization
    const ZOOM_IN_STEPS = [1.0, 1.1, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0, 4.0];
    const ZOOM_OUT_STEPS = [1.0, 0.9, 0.8, 0.75, 0.67, 0.5, 0.33, 0.25, 0.1];

    function findNearestStepIndex(scale, steps) {
      let nearestIndex = 0;
      let minDiff = Math.abs(scale - steps[0]);

      for (let i = 1; i < steps.length; i++) {
        const diff = Math.abs(scale - steps[i]);
        if (diff < minDiff) {
          minDiff = diff;
          nearestIndex = i;
        }
      }

      return nearestIndex;
    }

    // Replace the entire initializePanZoom function:
    globalThis.initializePanZoom = function () {
      const output = document.getElementById('output');
      if (!output) {
        console.error('Cannot initialize pan/zoom: output element not found');
        return;
      }

      // Capture current state BEFORE destroying instance
      let savedState = null;
      if (globalThis.panzoomInstance && globalThis.panzoomInitializedOnce) {
        try {
          const scale = globalThis.panzoomInstance.getScale();
          const pan = globalThis.panzoomInstance.getPan();
          savedState = { scale, panX: pan.x, panY: pan.y };
          console.log('Captured state before re-init:', savedState);
        } catch (e) {
          console.warn('Failed to capture state:', e);
        }
      }

      // Remove old event listeners to prevent memory leaks
      if (globalThis.panzoomEventHandlers) {
        const handlers = globalThis.panzoomEventHandlers;

        // Remove viewport-wide handlers from BODY
        if (handlers.wheelHandler) {
          document.body.removeEventListener('wheel', handlers.wheelHandler);
        }
        if (handlers.doubleClickHandler) {
          document.body.removeEventListener('dblclick', handlers.doubleClickHandler);
        }

        // Remove panzoom-specific handlers from OUTPUT
        if (handlers.zoomHandler) {
          output.removeEventListener('panzoomzoom', handlers.zoomHandler);
        }
        if (handlers.changeHandler) {
          output.removeEventListener('panzoomchange', handlers.changeHandler);
        }
        if (handlers.panLimitHandler) {
          output.removeEventListener('panzoomchange', handlers.panLimitHandler);
        }

        console.log('Cleaned up previous panzoom event listeners');
      }

      // Destroy existing panzoom instance
      if (globalThis.panzoomInstance) {
        try {
          globalThis.panzoomInstance.destroy();
          console.log('Destroyed previous panzoom instance');
        } catch (e) {
          console.warn('Error destroying previous panzoom instance:', e);
        }
      }

      // Create new panzoom instance with default starting position
      globalThis.panzoomInstance = Panzoom(output, {
        maxScale: 4,
        minScale: 0.1,
        step: 0.25,
        cursor: 'grab',
        animate: true,
        duration: 200,
        easing: 'ease-in-out',
        startScale: 1,
        startX: 0,
        startY: 0
      });

      // Restore saved state after creating new instance
      if (savedState) {
        try {
          globalThis.panzoomInstance.reset({ animate: false });

          if (savedState.scale !== 1.0) {
            globalThis.panzoomInstance.zoom(savedState.scale, { animate: false });
          }

          if (savedState.panX !== 0 || savedState.panY !== 0) {
            globalThis.panzoomInstance.pan(savedState.panX, savedState.panY, { animate: false });
          }

          console.log('Restored saved state:', savedState);
        } catch (e) {
          console.warn('Failed to restore state:', e);
        }
      }
      // Apply initial centering if no saved state
      else {
        console.log("=== ATTEMPTING INITIAL CENTERING ===");

        try {
          const svg = output.querySelector('svg');
          if (svg) {
            let svgWidth, svgHeight;
            if (svg.hasAttribute('viewBox')) {
              const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
              svgWidth = parseFloat(viewBox[2]);
              svgHeight = parseFloat(viewBox[3]);
            } else {
              svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
              svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
            }

            const containerWidth = output.offsetWidth;
            const containerHeight = output.offsetHeight;
            const outputPadding = 8;

            const panX = (containerWidth - svgWidth) / 2 - outputPadding;
            const panY = (containerHeight - svgHeight) / 2 - outputPadding;

            globalThis.panzoomInstance.pan(panX, panY, { animate: false });
            console.log(`Initial centering: pan=(${panX.toFixed(1)}, ${panY.toFixed(1)})`);
            console.log("=== INITIAL CENTERING COMPLETE ===");
          }
        } catch (e) {
          console.error('Failed initial centering:', e);
        }
      }

      // Event handlers (stored for cleanup)
      const wheelHandler = function (event) {
        event.preventDefault();
        if (globalThis.panzoomInstance) {
          globalThis.panzoomInstance.zoomWithWheel(event);
        }
      };

      const doubleClickHandler = function (event) {
        if (!event.target.closest('#zoom-toolbar')) {
          globalThis.fitToScreen();
        }
      };

      const zoomHandler = function () {
        updateZoomDisplay();
      };

      const changeHandler = function () {
        updateZoomDisplay();
      };

      // Pan limit handler with correct formula and thread-safety
      let lastPanLimitTime = 0;
      const panLimitDebounceMs = 16;

      const panLimitHandler = function () {
        if (!globalThis.panzoomInstance) return;

        const now = Date.now();
        if (now - lastPanLimitTime < panLimitDebounceMs) return;

        const pan = globalThis.panzoomInstance.getPan();
        const svg = output.querySelector('svg');
        if (!svg) return;

        let svgWidth, svgHeight;
        if (svg.hasAttribute('viewBox')) {
          const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
          svgWidth = parseFloat(viewBox[2]);
          svgHeight = parseFloat(viewBox[3]);
        } else {
          svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
          svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
        }

        const scale = globalThis.panzoomInstance.getScale();
        const containerWidth = output.offsetWidth;
        const containerHeight = output.offsetHeight;

        const minVisiblePercent = 0.2;
        const scaledWidth = svgWidth * scale;
        const scaledHeight = svgHeight * scale;

        const maxPanX = containerWidth * (1 - minVisiblePercent);
        const minPanX = -(scaledWidth - containerWidth * minVisiblePercent);
        const maxPanY = containerHeight * (1 - minVisiblePercent);
        const minPanY = -(scaledHeight - containerHeight * minVisiblePercent);

        const clampedX = Math.max(minPanX, Math.min(maxPanX, pan.x));
        const clampedY = Math.max(minPanY, Math.min(maxPanY, pan.y));

        if (clampedX !== pan.x || clampedY !== pan.y) {
          lastPanLimitTime = now;
          globalThis.panzoomInstance.pan(clampedX, clampedY, { animate: false, force: true });
        }
      };

      // Store handlers for cleanup
      globalThis.panzoomEventHandlers = {
        wheelHandler,
        doubleClickHandler,
        zoomHandler,
        changeHandler,
        panLimitHandler
      };

      // Initialize keyboard handler once
      if (!globalThis.keyboardPanInitialized) {
        document.addEventListener('keydown', handleKeyboardPan);
        globalThis.keyboardPanInitialized = true;
        console.log('Keyboard pan handler initialized (one-time setup)');
      }

      // Initialize toolbar dragging once
      const toolbar = document.getElementById('zoom-toolbar');
      if (toolbar && !toolbar.dataset.draggingInit) {
        initializeToolbarDragging(toolbar);
        toolbar.dataset.draggingInit = 'true';
        console.log('Toolbar dragging initialized (one-time setup)');
      }

      // Register event listeners
      // Viewport-wide handlers on BODY (zoom/dblclick anywhere in viewport)
      document.body.addEventListener('wheel', wheelHandler, { passive: false });
      document.body.addEventListener('dblclick', doubleClickHandler);

      // Panzoom-specific events on OUTPUT (where panzoom is attached)
      output.addEventListener('panzoomzoom', zoomHandler);
      output.addEventListener('panzoomchange', changeHandler);
      output.addEventListener('panzoomchange', panLimitHandler);

      // Show toolbar when pan/zoom is initialized
      if (toolbar) {
        toolbar.classList.remove('hidden');
      }

      globalThis.panzoomInitializedOnce = true;
      console.log('Pan/zoom initialized successfully (memory-safe, state-preserving)');
    };

    // Toolbar dragging functionality
    function initializeToolbarDragging(toolbar) {
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;

      const handleMouseMove = (e) => {
        if (!isDragging) return;

        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;

        // Keep toolbar within viewport bounds
        const rect = toolbar.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width;
        const maxY = window.innerHeight - rect.height;

        currentX = Math.max(0, Math.min(currentX, maxX));
        currentY = Math.max(0, Math.min(currentY, maxY));

        toolbar.style.right = 'auto'; // Clear fixed positioning
        toolbar.style.bottom = 'auto';
        toolbar.style.left = currentX + 'px';
        toolbar.style.top = currentY + 'px';
      };

      const handleMouseUp = () => {
        if (isDragging) {
          isDragging = false;
          toolbar.style.cursor = '';

          // Remove mousemove/mouseup listeners after drag ends
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        }
      };

      const handleMouseDown = (e) => {
        // Only allow dragging from toolbar background, not buttons
        if (e.target.closest('.zoom-button') || e.target.closest('#zoom-level-display')) {
          return;
        }

        isDragging = true;

        // Use offsetLeft/offsetTop to get rendered position
        // This correctly handles the initial fixed position (bottom: 20px, right: 20px)
        initialX = e.clientX - toolbar.offsetLeft;
        initialY = e.clientY - toolbar.offsetTop;

        toolbar.style.cursor = 'grabbing';

        // Attach mousemove/mouseup only during drag
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        e.preventDefault();
      };

      // Only attach mousedown handler (mousemove/mouseup are attached dynamically during drag)
      toolbar.addEventListener('mousedown', handleMouseDown);
    }

    // Keyboard pan: Defined at global scope (initialized once)
    // ArrowUp should pan UP (move content down = positive Y)
    // ArrowDown should pan DOWN (move content up = negative Y)
    // ArrowLeft should pan LEFT (move content right = positive X)
    // ArrowRight should pan RIGHT (move content left = negative X)
    function handleKeyboardPan(event) {
      if (!globalThis.panzoomInstance) return;

      // Check if user is typing in an input field
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
        return;
      }

      const panDistance = event.shiftKey ? 100 : 20;
      let handled = false;

      switch (event.key) {
        case 'ArrowUp':
          globalThis.panzoomInstance.pan(0, -panDistance, { relative: true });
          handled = true;
          break;
        case 'ArrowDown':
          globalThis.panzoomInstance.pan(0, panDistance, { relative: true });
          handled = true;
          break;
        case 'ArrowLeft':
          globalThis.panzoomInstance.pan(-panDistance, 0, { relative: true });
          handled = true;
          break;
        case 'ArrowRight':
          globalThis.panzoomInstance.pan(panDistance, 0, { relative: true });
          handled = true;
          break;
      }

      if (handled) {
        event.preventDefault();
        updateZoomDisplay();
      }
    }

    // Zoom display: Update function
    function updateZoomDisplay() {
      const display = document.getElementById('zoom-level-display');
      if (display && globalThis.panzoomInstance) {
        const scale = globalThis.panzoomInstance.getScale();
        display.textContent = `${Math.round(scale * 100)}%`;
      }
    }

    // Zoom control functions
    globalThis.zoomIn = function () {
      if (!globalThis.panzoomInstance) return;

      const output = document.getElementById('output');
      if (!output) return;

      const currentScale = globalThis.panzoomInstance.getScale();
      const currentIndex = findNearestStepIndex(currentScale, ZOOM_IN_STEPS);

      const nextIndex = Math.min(currentIndex + 1, ZOOM_IN_STEPS.length - 1);
      if (nextIndex === currentIndex) return;

      const targetScale = ZOOM_IN_STEPS[nextIndex];

      const outputRect = output.getBoundingClientRect();
      const syntheticEvent = {
        clientX: outputRect.left + outputRect.width / 2,
        clientY: outputRect.top + outputRect.height / 2
      };

      globalThis.panzoomInstance.zoomToPoint(targetScale, syntheticEvent, { animate: true });
      console.log(`Zoom In: ${Math.round(currentScale * 100)}%  ${Math.round(targetScale * 100)}%`);
    };

    globalThis.zoomOut = function () {
      if (!globalThis.panzoomInstance) return;

      const output = document.getElementById('output');
      if (!output) return;

      const currentScale = globalThis.panzoomInstance.getScale();
      const currentIndex = findNearestStepIndex(currentScale, ZOOM_OUT_STEPS);

      const nextIndex = Math.min(currentIndex + 1, ZOOM_OUT_STEPS.length - 1);
      if (nextIndex === currentIndex) return;

      const targetScale = ZOOM_OUT_STEPS[nextIndex];

      const outputRect = output.getBoundingClientRect();
      const syntheticEvent = {
        clientX: outputRect.left + outputRect.width / 2,
        clientY: outputRect.top + outputRect.height / 2
      };

      globalThis.panzoomInstance.zoomToPoint(targetScale, syntheticEvent, { animate: true });
      console.log(`Zoom Out: ${Math.round(currentScale * 100)}%  ${Math.round(targetScale * 100)}%`);
    };

    // Replace resetZoom function:
    globalThis.resetZoom = function () {
      if (!globalThis.panzoomInstance) return;

      const output = document.getElementById('output');
      const svg = output?.querySelector('svg');

      if (svg) {
        let svgWidth, svgHeight;
        if (svg.hasAttribute('viewBox')) {
          const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
          svgWidth = parseFloat(viewBox[2]);
          svgHeight = parseFloat(viewBox[3]);
        } else {
          svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
          svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
        }

        const containerWidth = output.offsetWidth;
        const containerHeight = output.offsetHeight;
        const outputPadding = 8;
        const panX = (containerWidth - svgWidth) / 2 - outputPadding;
        const panY = (containerHeight - svgHeight) / 2 - outputPadding;

        globalThis.panzoomInstance.zoom(1.0, { animate: false });
        globalThis.panzoomInstance.pan(panX, panY, { animate: false });

        console.log(`Reset: zoom=100%, pan=(${panX.toFixed(1)}, ${panY.toFixed(1)})`);
      }
    };

    // Replace centerDiagram function:
    globalThis.centerDiagram = function () {
      if (!globalThis.panzoomInstance) return;

      const output = document.getElementById('output');
      const svg = output?.querySelector('svg');

      if (svg) {
        let svgWidth, svgHeight;
        if (svg.hasAttribute('viewBox')) {
          const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
          svgWidth = parseFloat(viewBox[2]);
          svgHeight = parseFloat(viewBox[3]);
        } else {
          svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
          svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
        }

        const containerWidth = output.offsetWidth;
        const containerHeight = output.offsetHeight;
        const scale = globalThis.panzoomInstance.getScale();
        const outputPadding = 8;
        const panX = (containerWidth - svgWidth * scale) / 2 - outputPadding;
        const panY = (containerHeight - svgHeight * scale) / 2 - outputPadding;

        globalThis.panzoomInstance.pan(panX, panY, { animate: true });
        console.log(`Centered at ${Math.round(scale * 100)}%: pan=(${panX.toFixed(1)}, ${panY.toFixed(1)})`);
      }
    };

    // Fit-to-screen is idempotent. Uses intrinsic SVG dimensions and calculates proper center position
    // Removed 1.0 max scale limit to allow zooming out for large diagrams
    globalThis.fitToScreen = function () {
      if (!globalThis.panzoomInstance) return;

      const output = document.getElementById('output');
      const svg = output?.querySelector('svg');

      if (svg) {
        // Get intrinsic SVG dimensions (NOT scaled!)
        let svgWidth, svgHeight;
        if (svg.hasAttribute('viewBox')) {
          const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
          svgWidth = parseFloat(viewBox[2]);
          svgHeight = parseFloat(viewBox[3]);
        } else {
          // Fallback to attributes (avoid clientWidth/clientHeight as they may be scaled)
          svgWidth = parseFloat(svg.getAttribute('width')) || 800;
          svgHeight = parseFloat(svg.getAttribute('height')) || 600;
        }

        // CRITICAL FIX: Use offsetWidth/offsetHeight instead of getBoundingClientRect()
        // offsetWidth/offsetHeight return layout dimensions BEFORE transforms are applied
        const containerWidth = output.offsetWidth;
        const containerHeight = output.offsetHeight;

        // Calculate scale to fit with 40px diagram padding
        const diagramPadding = 40;
        const scaleX = (containerWidth - diagramPadding) / svgWidth;
        const scaleY = (containerHeight - diagramPadding) / svgHeight;
        const targetScale = Math.min(scaleX, scaleY);

        // Clamp to panzoom limits
        const minZoomScale = 0.1;
        const maxZoomScale = 4;
        const clampedScale = Math.max(minZoomScale, Math.min(maxZoomScale, targetScale));

        // Calculate centered pan at target scale
        const outputPadding = 8;
        const panX = (containerWidth - svgWidth * clampedScale) / 2 - outputPadding;
        const panY = (containerHeight - svgHeight * clampedScale) / 2 - outputPadding;

        // Apply both without animation to avoid conflicts
        globalThis.panzoomInstance.zoom(clampedScale, { animate: false });
        globalThis.panzoomInstance.pan(panX, panY, { animate: false });

        console.log(`Fit: scale=${(clampedScale * 100).toFixed(0)}%, pan=(${panX.toFixed(1)}, ${panY.toFixed(1)}), container=${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);
      }
    };

    // State management functions
    // Replace restoreViewState function:
    globalThis.restoreViewState = function (zoomLevel, panX, panY) {
      if (!globalThis.panzoomInstance) return;

      try {
        const output = document.getElementById('output');
        const svg = output?.querySelector('svg');
        const panToleranceThreshold = 0.1;
        const isPanNearZero = Math.abs(panX) < panToleranceThreshold && Math.abs(panY) < panToleranceThreshold;

        if (svg && isPanNearZero) {
          console.log('Detected default pan values - applying centering instead');

          let svgWidth, svgHeight;
          if (svg.hasAttribute('viewBox')) {
            const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
            svgWidth = parseFloat(viewBox[2]);
            svgHeight = parseFloat(viewBox[3]);
          } else {
            svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
            svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
          }

          const containerWidth = output.offsetWidth;
          const containerHeight = output.offsetHeight;
          const outputPadding = 8;
          const scale = zoomLevel || 1.0;

          const centeredPanX = (containerWidth - svgWidth * scale) / 2 - outputPadding;
          const centeredPanY = (containerHeight - svgHeight * scale) / 2 - outputPadding;

          globalThis.panzoomInstance.zoom(scale, { animate: false });
          globalThis.panzoomInstance.pan(centeredPanX, centeredPanY, { animate: false });

          console.log(`Applied centering: zoom=${(scale * 100).toFixed(0)}%, pan=(${centeredPanX.toFixed(1)}, ${centeredPanY.toFixed(1)})`);
        } else {
          globalThis.panzoomInstance.reset({ animate: false });

          if (zoomLevel && zoomLevel !== 1.0) {
            globalThis.panzoomInstance.zoom(zoomLevel, { animate: false });
          }

          globalThis.panzoomInstance.pan(panX, panY, { animate: false });

          console.log(`Restored view state: zoom=${(zoomLevel * 100).toFixed(0)}%, pan=(${panX.toFixed(1)}, ${panY.toFixed(1)})`);
        }

        updateZoomDisplay();
      } catch (e) {
        console.error('Error restoring view state:', e);
      }
    };

    // FIXED BUG #5: Return plain JSON object (not stringified)
    // C# will handle the serialization
    globalThis.getViewState = function () {
      if (globalThis.panzoomInstance) {
        const scale = globalThis.panzoomInstance.getScale();
        const pan = globalThis.panzoomInstance.getPan();
        // Return JSON string for C# ExecuteScriptAsync
        return JSON.stringify({
          zoom: scale,
          panX: pan.x,
          panY: pan.y
        });
      }
      // Return JSON string for default state
      return JSON.stringify({ zoom: 1.0, panX: 0, panY: 0 });
    };

    globalThis.debugPanZoom = function () {
      if (!globalThis.panzoomInstance) {
        console.log('No panzoom instance');
        return;
      }

      const output = document.getElementById('output');
      const svg = output?.querySelector('svg');

      if (!svg) {
        console.log('No SVG found');
        return;
      }

      // Get all dimensions
      let svgWidth, svgHeight;
      if (svg.hasAttribute('viewBox')) {
        const viewBox = svg.getAttribute('viewBox').split(/\s+|,/);
        svgWidth = parseFloat(viewBox[2]);
        svgHeight = parseFloat(viewBox[3]);
      } else {
        svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
        svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
      }

      const svgRect = svg.getBoundingClientRect();
      const outputRect = output.getBoundingClientRect();
      const scale = globalThis.panzoomInstance.getScale();
      const pan = globalThis.panzoomInstance.getPan();

      // Get computed transform for verification
      const transform = window.getComputedStyle(output).transform;

      console.log('=== PAN/ZOOM DEBUG INFO ===');
      console.log('SVG intrinsic dimensions:', { width: svgWidth, height: svgHeight });
      console.log('SVG bounding rect (scaled):', {
        width: svgRect.width,
        height: svgRect.height,
        left: svgRect.left,
        top: svgRect.top
      });
      console.log('Container bounding rect:', {
        width: outputRect.width,
        height: outputRect.height,
        left: outputRect.left,
        top: outputRect.top
      });
      console.log('Current scale:', scale);
      console.log('Current pan:', pan);
      console.log('Computed transform:', transform);
      console.log('SVG visual position relative to container:', {
        left: svgRect.left - outputRect.left,
        top: svgRect.top - outputRect.top
      });
      console.log('Expected centered position (if centered):', {
        left: (outputRect.width - svgRect.width) / 2,
        top: (outputRect.height - svgRect.height) / 2
      });
      console.log('========================');

      return {
        svgIntrinsic: { width: svgWidth, height: svgHeight },
        svgScaled: { width: svgRect.width, height: svgRect.height },
        container: { width: outputRect.width, height: outputRect.height },
        scale: scale,
        pan: pan,
        visualOffset: {
          left: svgRect.left - outputRect.left,
          top: svgRect.top - outputRect.top
        }
      };
    };
  </script>
</head>
<body>
  <div id="loading-container">
    <div class="spinner"></div>
    <div id="loading-status">Initializing...</div>
  </div>
  <div id="output"></div>
  <div id="zoom-toolbar" class="hidden">
    <div class="zoom-button" onclick="globalThis.zoomIn()">
      <span class="zoom-button-icon">+</span>
      <span>Zoom In</span>
    </div>
    <div class="zoom-button" onclick="globalThis.zoomOut()">
      <span class="zoom-button-icon"></span>
      <span>Zoom Out</span>
    </div>
    <div class="zoom-button" onclick="globalThis.resetZoom()">
      <span class="zoom-button-icon"></span>
      <span>Reset</span>
    </div>
    <div class="zoom-button" onclick="globalThis.centerDiagram()">
      <span class="zoom-button-icon"></span>
      <span>Center</span>
    </div>
    <div class="zoom-button" onclick="globalThis.fitToScreen()">
      <span class="zoom-button-icon"></span>
      <span>Fit to Screen</span>
    </div>
    <div id="zoom-level-display">100%</div>
  </div>
</body>
</html>
