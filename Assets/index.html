<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:;" />
  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MermaidPad Preview</title>
  <style>
    /* Paint correctly on first frame based on OS theme */
    html, body {
      margin: 0;
      height: 100%;
      background: #fff;
      color: #222;
    }

    @media (prefers-color-scheme: dark) {
      html, body {
        background: #1e1e1e;
        color: #ddd;
      }
    }

    body.dark-theme {
      background: #000;
      color: #ddd;
    }

    body.light-theme {
      background: #fff;
      color: #222;
    }

    /* CSS custom property for transition duration */
    :root {
      --loading-transition-duration: 300ms;
    }

    #output {
      padding: 8px;
      overflow: auto;
      height: 100vh;
      box-sizing: border-box;
      display: none;
    }

      #output.visible {
        display: block;
      }

    .error {
      color: #ff6f6f;
      white-space: pre;
      font-family: Consolas,monospace;
    }

    /* Loading indicator styles */
    #loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      transition: opacity var(--loading-transition-duration) ease-out, visibility 0s ease-out var(--loading-transition-duration);
    }

      #loading-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

    .spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 0.1875rem solid rgba(0, 0, 0, 0.1);
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spinner-rotate 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    body.dark-theme .spinner {
      border-color: rgba(255, 255, 255, 0.1);
      border-top-color: #4db8ff;
    }

    #loading-container.hidden .spinner {
      animation: none;
    }

    @keyframes spinner-rotate {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loading-status {
      position: absolute;
      top: calc(50% + 3rem);
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 1rem;
      color: #666;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      white-space: nowrap;
      will-change: transform;
    }

    body.dark-theme #loading-status {
      color: #aaa;
    }

    /* Mermaid dark theme overrides */
    body.dark-theme #output svg .messageLine,
    body.dark-theme #output svg .actor-line,
    body.dark-theme #output svg .mermaid .edgePath path,
    body.dark-theme #output svg .mermaid .node rect,
    body.dark-theme #output svg .mermaid .node circle,
    body.dark-theme #output svg .mermaid .node ellipse {
      stroke: #e0e0e0 !important;
    }

    body.dark-theme #output svg text,
    body.dark-theme #output svg .messageText {
      fill: #e0e0e0 !important;
    }
  </style>
  <!-- Apply theme immediately before any scripts load -->
  <script>
    // Immediate theme application to prevent flash
    (function() {
        const getSystemTheme = () => {
            if (globalThis.matchMedia && globalThis.matchMedia('(prefers-color-scheme: dark)').media !== 'not all') {
                return globalThis.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
            }
            return 'default';
        };

        const applyTheme = theme => {
            document.body.classList.toggle('dark-theme', theme === 'dark');
            document.body.classList.toggle('light-theme', theme === 'default');
        };

        // Store functions globally for reuse
        globalThis.getSystemTheme = getSystemTheme;
        globalThis.applyTheme = applyTheme;
        globalThis.currentTheme = getSystemTheme();

        // Apply theme immediately if body exists
        if (document.body) {
            applyTheme(globalThis.currentTheme);
        } else {
            // If body doesn't exist yet, apply on DOMContentLoaded
            document.addEventListener('DOMContentLoaded', function() {
                applyTheme(globalThis.currentTheme);
            }, { once: true });
        }
    })();
  </script>

  <!-- Load js-yaml first, no defer to avoid races -->
  <script src="js-yaml.min.js" id="jsyaml-script"></script>

  <!-- Load Mermaid, no defer to avoid races -->
  <script src="mermaid.min.js" id="mermaid-script"></script>

  <!-- Main initialization with proper event-driven loading -->
  <script type="module">
    // Global flags
    globalThis.elkLayoutAvailable = false;
    globalThis.mermaidInitialized = false;

    // Promise-based script loading with timeout
    function waitForScriptLoad(scriptId, timeout = 5000) {
        return new Promise((resolve, reject) => {
            const script = document.getElementById(scriptId);

            if (!script) {
                reject(new Error(`Script element with id '${scriptId}' not found`));
                return;
            }

            // Check if already loaded
            if (scriptId === 'mermaid-script' && typeof globalThis.mermaid !== 'undefined') {
                resolve();
                return;
            }
            if (scriptId === 'jsyaml-script' && typeof globalThis.jsyaml !== 'undefined') {
                resolve();
                return;
            }

            // Set up timeout
            const timeoutId = setTimeout(() => {
                reject(new Error(`Script '${scriptId}' load timeout after ${timeout}ms`));
            }, timeout);

            // Set up load event listener
            const handleLoad = () => {
                clearTimeout(timeoutId);
                resolve();
            };

            const handleError = (error) => {
                clearTimeout(timeoutId);
                reject(new Error(`Script '${scriptId}' failed to load: ${error.message || 'Unknown error'}`));
            };

            script.addEventListener('load', handleLoad, { once: true });
            script.addEventListener('error', handleError, { once: true });
        });
    }

    // Load ELK layout module
    async function loadElkLayout() {
        try {
            const elkModule = await import('./mermaid-elk-layout/mermaid-layout-elk.esm.min.mjs');
            const elkLayouts = elkModule.default;

            // Register ELK layouts with Mermaid
            globalThis.mermaid.registerLayoutLoaders(elkLayouts);
            globalThis.elkLayoutAvailable = true;
            console.log('ELK layout registered successfully');
            return true;
        } catch (err) {
            console.error('Failed to load ELK layout:', err);
            console.log('Continuing without ELK layout support');
            return false;
        }
    }

    // Main initialization function
    async function initializeApplication() {
        try {
            // Wait for both scripts to load
            console.log('Waiting for scripts to load...');
            await Promise.all([
                waitForScriptLoad('jsyaml-script'),
                waitForScriptLoad('mermaid-script')
            ]);

            console.log('Scripts loaded, initializing Mermaid...');

            // Update loading status
            globalThis.updateLoadingStatus('Loading rendering engine...');

            // Try to load ELK layout
            await loadElkLayout();

            // Initialize mermaid (with or without ELK)
            globalThis.mermaid.initialize({
                startOnLoad: false,
                theme: globalThis.currentTheme
            });

            // Set initialization flag
            globalThis.mermaidInitialized = true;
            console.log('Mermaid initialized successfully');

            // Process any pending render
            if (globalThis.pendingMermaidRender) {
                console.log('Processing pending render...');
                globalThis.renderMermaid(globalThis.pendingMermaidRender);
                globalThis.pendingMermaidRender = null;
            }
        } catch (error) {
            console.error('Failed to initialize application:', error);
            // Set flag to prevent infinite retries
            globalThis.mermaidInitializationFailed = true;

            // Hide loading indicator and show error
            globalThis.hideLoadingIndicator();

            const output = document.getElementById('output');
            if (output) {
                output.classList.add('visible');
                output.innerHTML = `<div class="error">Failed to initialize: ${error.message}</div>`;
            }
        }
    }

    // Start initialization
    initializeApplication();

    // Setup theme change listener
    document.addEventListener('DOMContentLoaded', () => {
        // Theme is already applied, but listen for changes
        if (globalThis.matchMedia) {
            globalThis.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                globalThis.currentTheme = e.matches ? 'dark' : 'default';
                globalThis.applyTheme(globalThis.currentTheme);

                // Re-render if we have content and Mermaid is initialized
                if (globalThis.lastMermaidSource && globalThis.mermaidInitialized) {
                    // Re-initialize Mermaid with new theme
                    globalThis.mermaid.initialize({
                        startOnLoad: false,
                        theme: globalThis.currentTheme
                    });
                    globalThis.renderMermaid(globalThis.lastMermaidSource);
                }
            });
        }
    });
  </script>
  <!-- Render functions in separate script -->
  <script>
        // Get transition duration from CSS custom property
        const getTransitionDuration = () => {
            const duration = getComputedStyle(document.documentElement)
                .getPropertyValue('--loading-transition-duration')
                .trim();
            // Remove 'ms' suffix and convert to number
            const numericValue = Number.parseFloat(duration.replace('ms', ''));
            return Number.isNaN(numericValue) ? 300 : numericValue; // Fallback to 300ms if parsing fails
        };

        // Loading indicator management
        globalThis.updateLoadingStatus = (message) => {
            const statusElement = document.getElementById('loading-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
        };

        globalThis.hideLoadingIndicator = () => {
            const loadingContainer = document.getElementById('loading-container');
            const output = document.getElementById('output');

            if (loadingContainer) {
                loadingContainer.classList.add('hidden');
                // Remove from DOM after transition completes (duration from CSS variable)
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, getTransitionDuration());
            }

            if (output) {
                output.classList.add('visible');
            }
        };

        // Render function with proper error handling
        globalThis.renderMermaid = source => {
            globalThis.lastMermaidSource = source; // Save for re-rendering
            const output = document.getElementById('output');

            // Helper functions
            const createErrorElement = (message) => {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message; // XSS-safe
                return errorDiv;
            };

            const showError = (message) => {
                // Hide loading indicator and show error
                globalThis.hideLoadingIndicator();
                output.innerHTML = '';
                output.appendChild(createErrorElement(message));
            };

            // ReSharper disable once InconsistentNaming
            const setSafeSVG = (htmlContent) => {
                const trimmed = htmlContent.trim();
                if (trimmed.startsWith('<svg') && trimmed.includes('</svg>')) {
                    output.innerHTML = htmlContent;
                } else {
                    showError('Invalid diagram content received');
                }
            };

            // Check if initialization failed
            if (globalThis.mermaidInitializationFailed) {
                showError('Mermaid initialization failed. Please refresh the page.');
                return;
            }

            // Check if mermaid is initialized
            if (!globalThis.mermaidInitialized) {
                // Store for later rendering
                globalThis.pendingMermaidRender = source;

                // Check if we should retry (with limit)
                if (!globalThis.renderRetryCount) {
                    globalThis.renderRetryCount = 0;
                }

                if (globalThis.renderRetryCount < 10) {
                    globalThis.renderRetryCount++;
                    setTimeout(() => globalThis.renderMermaid(source), 200);
                    return;
                } else {
                    showError('Mermaid is still loading. Please try again.');
                    globalThis.renderRetryCount = 0;
                    return;
                }
            }

            // Reset retry count on successful initialization
            globalThis.renderRetryCount = 0;

            // Parse front-matter config if present
            const fmRegex = /^---\s*([\s\S]*?)---\s*/;
            let diagramSource = source;
            const match = source.match(fmRegex);

            if (match) {
                try {
                    const parsed = globalThis.jsyaml.load(match[1]);
                    if (parsed && parsed.config) {
                        const customConfig = parsed.config;

                        // Re-initialize with new config
                        const configWithTheme = {
                            ...customConfig,
                            theme: customConfig.theme || globalThis.currentTheme,
                            startOnLoad: false
                        };

                        // Log config for debugging if using ELK
                        if (globalThis.elkLayoutAvailable && customConfig.flowchart?.defaultRenderer === 'elk') {
                            console.log('Using ELK layout with config:', configWithTheme);
                        }

                        globalThis.mermaid.initialize(configWithTheme);
                    }
                    // Remove front-matter from diagram source
                    diagramSource = source.replace(fmRegex, "");
                } catch (err) {
                    showError(`YAML parse error: ${err.message}`);
                    return;
                }
            }

            // Render the diagram
            const id = `mermaid-svg-${Date.now()}`;
            globalThis.mermaid.render(id, diagramSource)
                .then(result => {
                    setSafeSVG(result.svg);
                    if (typeof result.bindFunctions === 'function') {
                        result.bindFunctions(output);
                    }
                    // Hide loading indicator after diagram is successfully rendered
                    globalThis.hideLoadingIndicator();
                })
                .catch(e => {
                    showError(e.message);
                });
        };

        globalThis.clearOutput = () => {
            const output = document.getElementById('output');
            if (output) {
                output.innerHTML = '';
            }
        };

      // ==========================================
      // BROWSER-BASED PNG EXPORT FUNCTION
      // Renders the current diagram to PNG using canvas
      // ==========================================
      globalThis.exportToPNG = async function(options) {
          console.log('=== BROWSER-BASED PNG EXPORT STARTED ===');
          console.log('Export options:', options);

          try {
              // Set status for polling
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'initializing', 
                  percent: 0, 
                  message: 'Starting PNG export...' 
              });

              // Validate we have diagram source
              if (!globalThis.lastMermaidSource) {
                  throw new Error('No diagram source available for export');
              }

              // Parse options with defaults
              const scale = options?.scale || 2;
              const backgroundColor = options?.backgroundColor || 'white';
              const dpi = options?.dpi || 96;
              
              // Calculate DPI scale (96 is the baseline DPI)
              const dpiScale = dpi / 96;
              const effectiveScale = scale * dpiScale;

              console.log(`Using scale: ${scale}, DPI: ${dpi}, effective scale: ${effectiveScale}`);

              // Update progress: Rendering
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'rendering', 
                  percent: 20, 
                  message: 'Rendering diagram...' 
              });

              // Render fresh SVG with current config
              const id = `png-export-${Date.now()}`;
              const renderResult = await globalThis.mermaid.render(id, globalThis.lastMermaidSource);

              if (!renderResult?.svg) {
                  throw new Error('Failed to render diagram for PNG export');
              }

              // Update progress: Creating canvas
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'creating-canvas', 
                  percent: 40, 
                  message: 'Creating canvas...' 
              });

              // Create temporary container for SVG
              const container = document.createElement('div');
              container.style.position = 'absolute';
              container.style.left = '-99999px';
              container.style.top = '-99999px';
              container.innerHTML = renderResult.svg;
              document.body.appendChild(container);

              const svgElement = container.querySelector('svg');
              if (!svgElement) {
                  document.body.removeChild(container);
                  throw new Error('Could not find SVG element in rendered output');
              }

              // Get dimensions from viewBox or bounding box
              const viewBox = svgElement.getAttribute('viewBox');
              let width, height;

              if (viewBox) {
                  const parts = viewBox.split(' ');
                  width = Number.parseFloat(parts[2]);
                  height = Number.parseFloat(parts[3]);
              } else {
                  const bbox = svgElement.getBoundingClientRect();
                  width = bbox.width || 800;
                  height = bbox.height || 600;
              }

              const scaledWidth = Math.round(width * effectiveScale);
              const scaledHeight = Math.round(height * effectiveScale);
              const totalPixels = scaledWidth * scaledHeight;
              const estimatedMemoryMB = (totalPixels * 4) / (1024 * 1024); // 4 bytes per pixel
              
              console.log(`SVG dimensions: ${width}x${height}, scaled: ${scaledWidth}x${scaledHeight}`);
              console.log(`Total pixels: ${totalPixels.toLocaleString()}, estimated memory: ${estimatedMemoryMB.toFixed(0)} MB`);

              // Validate canvas size limits
              const maxDimension = 32767; // Browser spec limit per dimension
              const maxPixels = 16384 * 16384; // 16384 x 16384 = 256M pixels (practical limit)
              const maxMemoryMB = 1024; // 1 GB practical memory limit
              
              if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                  document.body.removeChild(container);
                  throw new Error(`Canvas dimension exceeds browser limit of ${maxDimension} pixels. Current: ${scaledWidth}x${scaledHeight}. Try reducing scale or DPI.`);
              }
              
              if (totalPixels > maxPixels) {
                  document.body.removeChild(container);
                  const oneMillion = 1000000;
                  throw new Error(`Canvas size too large (${(totalPixels / oneMillion).toFixed(1)}M pixels). Maximum recommended: ${(maxPixels / oneMillion).toFixed(0)}M pixels. Try reducing scale or DPI.`);
              }
              
              if (estimatedMemoryMB > maxMemoryMB) {
                  document.body.removeChild(container);
                  throw new Error(`Estimated memory usage (${estimatedMemoryMB.toFixed(0)} MB) exceeds safe limit of ${maxMemoryMB} MB. Try reducing scale or DPI.`);
              }

              // Update progress: Converting to bitmap
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'converting', 
                  percent: 60, 
                  message: 'Converting to bitmap...' 
              });

              // Create canvas with scaled dimensions
              const canvas = document.createElement('canvas');
              canvas.width = scaledWidth;
              canvas.height = scaledHeight;

              const ctx = canvas.getContext('2d');
              if (!ctx) {
                  document.body.removeChild(container);
                  throw new Error('Failed to get canvas 2D context');
              }

              // Scale context for high-DPI rendering
              ctx.scale(effectiveScale, effectiveScale);

              // Draw background if not transparent
              if (backgroundColor && backgroundColor.toLowerCase() !== 'transparent') {
                  ctx.fillStyle = backgroundColor;
                  ctx.fillRect(0, 0, width, height);
              }

              // Serialize SVG to string
              const svgString = new XMLSerializer().serializeToString(svgElement);
              
              // Clean up DOM
              document.body.removeChild(container);

              // Convert SVG to data URI (avoids canvas tainting issues with blob URLs)
              // Encode the SVG string properly for data URI
              const encodedSvg = encodeURIComponent(svgString)
                  .replace(/'/g, '%27')
                  .replace(/"/g, '%22');
              
              const dataUri = `data:image/svg+xml;charset=utf-8,${encodedSvg}`;

              // Load SVG into image
              const img = new Image();
              
              // Create promise for image loading
              const imageLoadPromise = new Promise((resolve, reject) => {
                  img.onload = () => {
                      resolve();
                  };

                  img.onerror = (error) => {
                      reject(new Error(`Failed to load SVG as image: ${error}`));
                  };

                  // Set timeout for image loading (30 seconds)
                  setTimeout(() => {
                      reject(new Error('Image loading timeout'));
                  }, 30000);
              });

              img.src = dataUri;
              await imageLoadPromise;

              // Update progress: Drawing to canvas
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'drawing', 
                  percent: 80, 
                  message: 'Drawing to canvas...' 
              });

              // Draw image to canvas
              ctx.drawImage(img, 0, 0, width, height);

              // Update progress: Encoding
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'encoding', 
                  percent: 90, 
                  message: 'Encoding PNG...' 
              });

              // Convert canvas to PNG data URL
              const dataUrl = canvas.toDataURL('image/png');
              
              // Validate that toDataURL() succeeded
              // Validate that toDataURL() succeeded
              // Some browsers return 'data:,' if canvas.toDataURL() fails (e.g., canvas is empty, too large, or encoding error)
              if (!dataUrl || dataUrl === 'data:,' || !dataUrl.includes(',')) {
                  throw new Error('Failed to encode canvas to PNG. The canvas size may be too large for this browser. Try reducing scale or DPI.');
              }
              
              // Extract base64 data (remove "data:image/png;base64," prefix)
              const base64Data = dataUrl.split(',')[1];
              
              // Validate base64 data
              if (!base64Data || base64Data.length === 0) {
                  throw new Error('PNG encoding produced empty data. Try reducing scale or DPI.');
              }

              // Update progress: Complete
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'complete', 
                  percent: 100, 
                  message: 'Export complete!' 
              });

              console.log('✓ PNG export successful, data length:', base64Data.length);

              // Store result for retrieval
              globalThis.__pngExportResult__ = base64Data;

              return { 
                  success: true, 
                  dataLength: base64Data.length,
                  dimensions: { width: canvas.width, height: canvas.height }
              };

          } catch (error) {
              console.error('✗ PNG export failed:', error);
              
              globalThis.__pngExportStatus__ = JSON.stringify({ 
                  step: 'error', 
                  percent: 0, 
                  message: error.message 
              });

              globalThis.__pngExportResult__ = null;

              return { 
                  success: false, 
                  error: error.message 
              };
          }
      };

      console.log('Browser-based PNG export function registered: globalThis.exportToPNG');

      // Legacy export functions (kept for compatibility)
      globalThis.exportDiagram = {
          getSVG: () => {
            try {
                const svg = document.querySelector('#output svg');
                if (!svg) {
                    console.error('No SVG found in output');
                    return null;
                }

                // Clone and ensure proper attributes
                const clone = svg.cloneNode(true);
                clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

                // Mermaid already includes styles, just serialize
                return new XMLSerializer().serializeToString(clone);
            } catch (error) {
                console.error('Error getting SVG:', error);
                return null;
            }
        }
    };
  </script>
</head>
<body>
  <div id="loading-container">
    <div class="spinner"></div>
    <div id="loading-status">Initializing...</div>
  </div>
  <div id="output"></div>
</body>
</html>
