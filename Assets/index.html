<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:;" />
  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MermaidPad Preview</title>
  <style>
    /* Paint correctly on first frame based on OS theme */
    html, body {
      margin: 0;
      height: 100%;
      background: #fff;
      color: #222;
    }

    @media (prefers-color-scheme: dark) {
      html, body {
        background: #1e1e1e;
        color: #ddd;
      }
    }

    body.dark-theme {
      background: #000;
      color: #ddd;
    }

    body.light-theme {
      background: #fff;
      color: #222;
    }

    /* CSS custom property for transition duration */
    :root {
      --loading-transition-duration: 300ms;
    }

    #output {
      padding: 8px;
      overflow: auto;
      height: 100vh;
      box-sizing: border-box;
      display: none;
    }

      #output.visible {
        display: block;
      }

    .error {
      color: #ff6f6f;
      white-space: pre;
      font-family: Consolas,monospace;
    }

    /* Loading indicator styles */
    #loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      transition: opacity var(--loading-transition-duration) ease-out, visibility 0s ease-out var(--loading-transition-duration);
    }

      #loading-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

    .spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 0.1875rem solid rgba(0, 0, 0, 0.1);
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spinner-rotate 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    body.dark-theme .spinner {
      border-color: rgba(255, 255, 255, 0.1);
      border-top-color: #4db8ff;
    }

    #loading-container.hidden .spinner {
      animation: none;
    }

    @keyframes spinner-rotate {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loading-status {
      position: absolute;
      top: calc(50% + 3rem);
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 1rem;
      color: #666;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      white-space: nowrap;
      will-change: transform;
    }

    body.dark-theme #loading-status {
      color: #aaa;
    }

    /* Mermaid dark theme overrides */
    body.dark-theme #output svg .messageLine,
    body.dark-theme #output svg .actor-line,
    body.dark-theme #output svg .mermaid .edgePath path,
    body.dark-theme #output svg .mermaid .node rect,
    body.dark-theme #output svg .mermaid .node circle,
    body.dark-theme #output svg .mermaid .node ellipse {
      stroke: #e0e0e0 !important;
    }

    body.dark-theme #output svg text,
    body.dark-theme #output svg .messageText {
      fill: #e0e0e0 !important;
    }

    /* ============================================
    HOVER HIGHLIGHTING STYLES FOR MERMAID DIAGRAMS
    ============================================ */

    /* Enable smooth transitions for all interactive elements */
    #output svg .node,
    #output svg .edgePath path,
    #output svg .flowchart-link,
    #output svg .actor,
    #output svg .activation,
    #output svg rect,
    #output svg circle,
    #output svg ellipse,
    #output svg polygon,
    #output svg path,
    #output svg .messageText,
    #output svg .labelText,
    #output svg .nodeLabel,
    #output svg .edgeLabel {
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }

    /* ============================================
    LIGHT THEME HOVER EFFECTS
    ============================================ */

    /* Node hover effects - Light theme */
    body.light-theme #output svg .node:hover rect,
    body.light-theme #output svg .node:hover circle,
    body.light-theme #output svg .node:hover ellipse,
    body.light-theme #output svg .node:hover polygon {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* Node label hover - Light theme */
    body.light-theme #output svg .node:hover .nodeLabel,
    body.light-theme #output svg .node:hover text {
      font-weight: 600 !important;
      fill: #005a9e !important;
    }

    /* Edge/Path hover effects - Light theme */
    body.light-theme #output svg .edgePath:hover path,
    body.light-theme #output svg .flowchart-link:hover {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    /* Edge label hover - Light theme */
    body.light-theme #output svg .edgeLabel:hover,
    body.light-theme #output svg .edgeLabel:hover text {
      fill: #005a9e !important;
      font-weight: 600 !important;
    }

    /* Sequence diagram specific - Light theme */
    body.light-theme #output svg .actor:hover rect,
    body.light-theme #output svg .actor:hover circle {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    body.light-theme #output svg .activation:hover rect {
      fill: #cce5ff !important;
      stroke: #007acc !important;
      stroke-width: 2px !important;
    }

    body.light-theme #output svg .messageLine:hover {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    /* Class diagram specific - Light theme */
    body.light-theme #output svg .classGroup:hover rect {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* State diagram specific - Light theme */
    body.light-theme #output svg .stateGroup:hover rect,
    body.light-theme #output svg .stateGroup:hover circle {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
    }

    /* ============================================
    DARK THEME HOVER EFFECTS
    ============================================ */

    /* Node hover effects - Dark theme */
    body.dark-theme #output svg .node:hover rect,
    body.dark-theme #output svg .node:hover circle,
    body.dark-theme #output svg .node:hover ellipse,
    body.dark-theme #output svg .node:hover polygon {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* Node label hover - Dark theme */
    body.dark-theme #output svg .node:hover .nodeLabel,
    body.dark-theme #output svg .node:hover text {
      font-weight: 600 !important;
      fill: #ffffff !important;
      filter: drop-shadow(0 0 4px rgba(77, 184, 255, 0.8));
    }

    /* Edge/Path hover effects - Dark theme */
    body.dark-theme #output svg .edgePath:hover path,
    body.dark-theme #output svg .flowchart-link:hover {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    /* Edge label hover - Dark theme */
    body.dark-theme #output svg .edgeLabel:hover,
    body.dark-theme #output svg .edgeLabel:hover text {
      fill: #ffffff !important;
      font-weight: 600 !important;
      filter: drop-shadow(0 0 4px rgba(77, 184, 255, 0.8));
    }

    /* Sequence diagram specific - Dark theme */
    body.dark-theme #output svg .actor:hover rect,
    body.dark-theme #output svg .actor:hover circle {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    body.dark-theme #output svg .activation:hover rect {
      fill: #1a4d6b !important;
      stroke: #4db8ff !important;
      stroke-width: 2px !important;
    }

    body.dark-theme #output svg .messageLine:hover {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
      filter: drop-shadow(0 0 6px rgba(77, 184, 255, 0.5));
    }

    /* Class diagram specific - Dark theme */
    body.dark-theme #output svg .classGroup:hover rect {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* State diagram specific - Dark theme */
    body.dark-theme #output svg .stateGroup:hover rect,
    body.dark-theme #output svg .stateGroup:hover circle {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
    }

    /* ============================================
    ADDITIONAL HOVER ENHANCEMENTS
    ============================================ */

    /* Pie chart segments */
    body.light-theme #output svg .pieCircle:hover {
      filter: brightness(1.2) drop-shadow(0 0 8px rgba(0, 122, 204, 0.6));
      transform: scale(1.05);
      transform-origin: center;
    }

    body.dark-theme #output svg .pieCircle:hover {
      filter: brightness(1.3) drop-shadow(0 0 10px rgba(77, 184, 255, 0.7));
      transform: scale(1.05);
      transform-origin: center;
    }

    /* Gantt chart bars */
    body.light-theme #output svg .task:hover {
      filter: brightness(1.15) drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    body.dark-theme #output svg .task:hover {
      filter: brightness(1.25) drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    /* Generic rect elements (fallback for all diagram types) */
    body.light-theme #output svg rect:hover {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    body.dark-theme #output svg rect:hover {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
    }

    /* Improve hover cursor for all interactive elements */
    #output svg .node,
    #output svg .edgePath,
    #output svg .actor,
    #output svg .classGroup,
    #output svg .stateGroup,
    #output svg .task,
    #output svg .pieCircle {
      cursor: pointer;
    }

    /* Prevent text selection during hover interactions */
    #output svg text {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* ============================================
    CLASS-BASED HOVER EFFECTS (for JavaScript-triggered hovers)
    Mirror the :hover rules above for .hover-active class.

    Why both :hover and .hover-active?
      The :hover pseudo-class handles direct pointer hovers on elements,
      providing immediate visual feedback when the user hovers over an element.
      The .hover-active class is applied via JavaScript to enable hover effects
      on elements that may not be directly hovered (e.g., hit areas, accessibility
      features, or programmatic interactions). This ensures consistent hover
      styling whether triggered by pointer events or by script.
    ============================================ */

    /* Light theme - class-based hover for paths/edges */
    body.light-theme #output svg path.hover-active,
    body.light-theme #output svg .edgePath path.hover-active,
    body.light-theme #output svg .flowchart-link.hover-active {
      stroke: #007acc !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 6px rgba(0, 122, 204, 0.5));
    }

    body.light-theme #output svg line.hover-active,
    body.light-theme #output svg .messageLine.hover-active {
      stroke: #007acc !important;
      stroke-width: 2.5px !important;
    }

    /* Dark theme - class-based hover for paths/edges */
    body.dark-theme #output svg path.hover-active,
    body.dark-theme #output svg .edgePath path.hover-active,
    body.dark-theme #output svg .flowchart-link.hover-active {
      stroke: #4db8ff !important;
      stroke-width: 3px !important;
      filter: drop-shadow(0 0 8px rgba(77, 184, 255, 0.6));
    }

    body.dark-theme #output svg line.hover-active,
    body.dark-theme #output svg .messageLine.hover-active {
      stroke: #4db8ff !important;
      stroke-width: 2.5px !important;
      filter: drop-shadow(0 0 6px rgba(77, 184, 255, 0.5));
    }
  </style>
  <!-- Apply theme immediately before any scripts load -->
  <script>
    // Immediate theme application to prevent flash
    (function () {
      const getSystemTheme = () => {
        if (globalThis.matchMedia && globalThis.matchMedia('(prefers-color-scheme: dark)').media !== 'not all') {
          return globalThis.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        }
        return 'default';
      };

      const applyTheme = theme => {
        document.body.classList.toggle('dark-theme', theme === 'dark');
        document.body.classList.toggle('light-theme', theme === 'default');
      };

      // Store functions globally for reuse
      globalThis.getSystemTheme = getSystemTheme;
      globalThis.applyTheme = applyTheme;
      globalThis.currentTheme = getSystemTheme();

      //Apply theme immediately and set up the persistent listener
      const matcher = globalThis.matchMedia?.('(prefers-color-scheme: dark)');

      const applyInitialThemeAndSetupListener = () => {
        if (document.body) {
          applyTheme(globalThis.currentTheme);
        }

        if (matcher) {
          matcher.addEventListener('change', e => {
            globalThis.currentTheme = e.matches ? 'dark' : 'default';
            globalThis.applyTheme(globalThis.currentTheme);

            // Note: We don't re-render the mermaid diagram here.
            // The re-render logic should remain in the subsequent script block
            // which has access to mermaid.
          });
        }
      };

      if (document.body) {
        applyInitialThemeAndSetupListener();
      } else {
        document.addEventListener('DOMContentLoaded', applyInitialThemeAndSetupListener, { once: true });
      }
    })();
  </script>

  <!-- Load js-yaml first, no defer to avoid races -->
  <script src="js-yaml.min.js" id="jsyaml-script"></script>

  <!-- Load Mermaid, no defer to avoid races -->
  <script src="mermaid.min.js" id="mermaid-script"></script>

  <!-- Main initialization with proper event-driven loading -->
  <script type="module">
    // Global flags
    globalThis.elkLayoutAvailable = false;
    globalThis.mermaidInitialized = false;

    // Promise-based script loading with timeout
    function waitForScriptLoad(scriptId, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const script = document.getElementById(scriptId);

        if (!script) {
          reject(new Error(`Script element with id '${scriptId}' not found`));
          return;
        }

        // Check if already loaded
        if (scriptId === 'mermaid-script' && globalThis.mermaid !== undefined) {
          resolve();
          return;
        }
        if (scriptId === 'jsyaml-script' && globalThis.jsyaml !== undefined) {
          resolve();
          return;
        }

        // Set up timeout
        const timeoutId = setTimeout(() => {
          reject(new Error(`Script '${scriptId}' load timeout after ${timeout}ms`));
        }, timeout);

        // Set up load event listener
        const handleLoad = () => {
          clearTimeout(timeoutId);
          resolve();
        };

        const handleError = (error) => {
          clearTimeout(timeoutId);
          reject(new Error(`Script '${scriptId}' failed to load: ${error.message || 'Unknown error'}`));
        };

        script.addEventListener('load', handleLoad, { once: true });
        script.addEventListener('error', handleError, { once: true });
      });
    }

    // Load ELK layout module
    async function loadElkLayout() {
      try {
        const elkModule = await import('./mermaid-elk-layout/mermaid-layout-elk.esm.min.mjs');
        const elkLayouts = elkModule.default;

        // Register ELK layouts with Mermaid
        globalThis.mermaid.registerLayoutLoaders(elkLayouts);
        globalThis.elkLayoutAvailable = true;
        console.log('ELK layout registered successfully');
        return true;
      } catch (err) {
        console.error('Failed to load ELK layout:', err);
        console.log('Continuing without ELK layout support');
        return false;
      }
    }

    // Main initialization function (call-site uses suppressHideLoadingIndicator: true)
    async function initializeApplication() {
      try {
        // Wait for both scripts to load
        console.log('Waiting for scripts to load...');
        await Promise.all([
          waitForScriptLoad('jsyaml-script'),
          waitForScriptLoad('mermaid-script')
        ]);

        console.log('Scripts loaded, initializing Mermaid...');

        // Update loading status
        globalThis.updateLoadingStatus('Loading rendering engine...');

        // Try to load ELK layout
        await loadElkLayout();

        // Initialize mermaid (with or without ELK)
        globalThis.mermaid.initialize({
          startOnLoad: false,
          theme: globalThis.currentTheme
        });

        // Set initialization flag
        globalThis.mermaidInitialized = true;
        console.log('Mermaid initialized successfully');

        // Process any pending render without impacting init state
        if (globalThis.pendingMermaidRender) {
          console.log('Processing pending render...');
          try {
            // Tell renderMermaid to NOT hide the loading indicator (init owns it)
            const renderResult = await globalThis.renderMermaid(globalThis.pendingMermaidRender, { suppressHideLoadingIndicator: true });
            if (!renderResult?.success) {
              // Error already rendered by renderMermaid; just log.
              console.warn('Pending render failed.');
            }
          } catch (renderError) {
            // Guard: renderMermaid should return a result rather than throw, but protect anyway.
            console.error('Failed to render Mermaid diagram:', renderError);
          } finally {
            globalThis.pendingMermaidRender = null;
          }
        }
      } catch (error) {
        console.error('Failed to initialize application:', error);
        // Set flag to prevent infinite retries (this is for init failures only)
        globalThis.mermaidInitializationFailed = true;

        const output = document.getElementById('output');
        if (output) {
          output.classList.add('visible');
          output.innerHTML = `<div class="error">Failed to initialize: ${error.message}</div>`;
        }
      } finally {
        // Always hide the loading indicator after all initialization and any pending render
        console.debug('Initialization complete, hiding loading indicator.');
        globalThis.hideLoadingIndicator();
      }
    }

    // Start initialization - use top-level await (module)
    try {
      await initializeApplication();
    } catch (err) {
      console.error('initializeApplication failed:', err);
    }

    // Setup theme change listener
    document.addEventListener('DOMContentLoaded', () => {
      // Theme is already applied, but listen for changes
      if (globalThis.matchMedia) {
        globalThis.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
          globalThis.currentTheme = e.matches ? 'dark' : 'default';
          globalThis.applyTheme(globalThis.currentTheme);

          // Re-render if we have content and Mermaid is initialized
          if (globalThis.lastMermaidSource && globalThis.mermaidInitialized) {
            // Re-initialize Mermaid with new theme
            globalThis.mermaid.initialize({
              startOnLoad: false,
              theme: globalThis.currentTheme
            });
            globalThis.renderMermaid(globalThis.lastMermaidSource);
          }
        });
      }
    });
  </script>
  <!-- Render functions in separate script -->
  <script>
    // Get transition duration from CSS custom property
    const getTransitionDuration = () => {
      const duration = getComputedStyle(document.documentElement)
        .getPropertyValue('--loading-transition-duration')
        .trim();
      // Remove 'ms' suffix and convert to number
      const numericValue = Number.parseFloat(duration.replace('ms', ''));
      return Number.isNaN(numericValue) ? 300 : numericValue; // Fallback to 300ms if parsing fails
    };

    // Loading indicator management
    globalThis.updateLoadingStatus = (message) => {
      const statusElement = document.getElementById('loading-status');
      if (statusElement) {
        statusElement.textContent = message;
      }
    };

    globalThis.hideLoadingIndicator = () => {
      const loadingContainer = document.getElementById('loading-container');
      const output = document.getElementById('output');

      if (loadingContainer) {
        loadingContainer.classList.add('hidden');
        // Remove from DOM after transition completes (duration from CSS variable)
        setTimeout(() => {
          loadingContainer.style.display = 'none';
        }, getTransitionDuration());
      }

      if (output) {
        output.classList.add('visible');
      }

      try {
        // Set the flag for C# polling (AvaloniaWebView doesn't support postMessage events)
        globalThis.__renderingComplete__ = true;

        // Try platform-specific notifications

        // Try WebView2 (Windows) - check existence on globalThis to avoid implicit declaration warning
        if (globalThis.chrome && globalThis.chrome.webview && globalThis.chrome.webview.postMessage) {
          try {
            globalThis.chrome.webview.postMessage('renderingComplete');
          } catch (chromeError) {
            // Silently ignore - AvaloniaWebView may not support this
            console.debug('chrome.webview.postMessage failed:', chromeError.message);
          }
        }

        // Try WebKit (macOS/Linux) - check existence on globalThis to avoid implicit declaration warning
        if (globalThis.webkit && globalThis.webkit.messageHandlers && globalThis.webkit.messageHandlers.renderingComplete) {
          try {
            globalThis.webkit.messageHandlers.renderingComplete.postMessage('');
          } catch (webkitError) {
            // Silently ignore - AvaloniaWebView may not support this
            console.debug('webkit.messageHandlers failed:', webkitError.message);
          }
        }
      } catch (outerError) {
        // Even if postMessage fails, ensure the flag is set
        console.error('Error in render completion notification:', outerError.message);
        globalThis.__renderingComplete__ = true;
      }
    };

    // Render function with proper error handling
    // signature: renderMermaid(source, options = { suppressHideLoadingIndicator: false })
    globalThis.renderMermaid = async (source, options = {}) => {
      const suppressHide = !!options.suppressHideLoadingIndicator;
      globalThis.lastMermaidSource = source; // Save for re-rendering
      const output = document.getElementById('output');

      // Helper functions
      const createErrorElement = (message) => {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.textContent = message; // XSS-safe
        return errorDiv;
      };

      const showError = (message) => {
        // Render error into output; hide loader only if caller did not suppress it.
        if (output) {
          output.innerHTML = '';
          output.appendChild(createErrorElement(message));
        }
        if (!suppressHide) {
          try {
            globalThis.hideLoadingIndicator();
          } catch (e) {
            console.error('Error hiding loading indicator:', e);
          }
        }
      };

      // ReSharper disable once InconsistentNaming
      const setSafeSVG = (htmlContent) => {
        const trimmed = htmlContent.trim();
        if (trimmed.startsWith('<svg') && trimmed.includes('</svg>')) {
          if (output) {
            output.innerHTML = htmlContent;
          }
          // Enhance hover interactivity after SVG is rendered
          if (typeof globalThis.enhanceHoverability === 'function') {
            const hoverActivationDelay = globalThis.elkLayoutAvailable ? 200 : 50; // ms
            setTimeout(() => globalThis.enhanceHoverability(), hoverActivationDelay);
          }
        } else {
          showError('Invalid diagram content received');
        }
      };

      // Check if initialization failed
      if (globalThis.mermaidInitializationFailed) {
        showError('Mermaid initialization failed. Please refresh the page.');
        return { success: false, error: 'Initialization failed' };
      }

      // Check if mermaid is initialized
      if (!globalThis.mermaidInitialized) {
        // Store for later rendering
        globalThis.pendingMermaidRender = source;

        // Retry logic (same behavior, but return a result)
        if (!globalThis.renderRetryCount) {
          globalThis.renderRetryCount = 0;
        }

        if (globalThis.renderRetryCount < 10) {
          globalThis.renderRetryCount++;
          setTimeout(() => globalThis.renderMermaid(source, options), 200);
          return { success: false, error: 'Mermaid is initializing; retry scheduled' };
        } else {
          try {
            showError('Mermaid is still loading. Please try again.');
            return { success: false, error: 'Mermaid loading timeout' };
          } finally {
            // Ensure retry count is reset even if showError throws
            globalThis.renderRetryCount = 0;
          }
        }
      }

      // Reset retry count on successful initialization path
      globalThis.renderRetryCount = 0;

      // Parse front-matter config if present
      const fmRegex = /^---\s*([\s\S]*?)---\s*/;
      let diagramSource = source;
      const match = source.match(fmRegex);

      if (match) {
        try {
          const parsed = globalThis.jsyaml.load(match[1]);
          if (parsed && parsed.config) {
            const customConfig = parsed.config;

            // Re-initialize with new config
            const configWithTheme = {
              ...customConfig,
              theme: customConfig.theme || globalThis.currentTheme,
              startOnLoad: false
            };

            // Log config for debugging if using ELK
            if (globalThis.elkLayoutAvailable && customConfig.flowchart?.defaultRenderer === 'elk') {
              console.log('Using ELK layout with config:', configWithTheme);
            }

            globalThis.mermaid.initialize(configWithTheme);
          }
          // Remove front-matter from diagram source
          diagramSource = source.replace(fmRegex, "");
        } catch (err) {
          showError(`YAML parse error: ${err.message}`);
          return { success: false, error: `YAML parse error: ${err.message}` };
        }
      }

      // Render the diagram
      const id = `mermaid-svg-${Date.now()}`;
      try {
        const result = await globalThis.mermaid.render(id, diagramSource);
        setSafeSVG(result.svg);
        if (typeof result.bindFunctions === 'function') {
          result.bindFunctions(output);
        }
        // Hide loader for normal renders (unless caller suppressed)
        if (!suppressHide) {
          try {
            globalThis.hideLoadingIndicator();
          } catch (e) {
            console.error('Error hiding loading indicator', e);
          }
        }
        return { success: true };
      } catch (e) {
        showError(e.message);
        // Do NOT rethrow; return a failure result to avoid leaking into init failure path
        return { success: false, error: e.message };
      }
    };

    globalThis.clearOutput = () => {
      const output = document.getElementById('output');
      if (output) {
        output.innerHTML = '';
      }
    };

    // ==========================================
    // BROWSER-BASED PNG EXPORT FUNCTION
    // Renders the current diagram to PNG using canvas
    // ==========================================
    globalThis.exportToPNG = async function (options) {
      console.log('Browser-based PNG export started');
      console.log('Export options:', options);

      // Helper to set status and notify host (if available)
      const setExportStatus = (statusObj) => {
        try {
          const json = JSON.stringify(statusObj);
          globalThis.__pngExportStatus__ = json;

          // Prefer WebView2 style postMessage (safe check using globalThis)
          const webviewPostMessage = globalThis.chrome?.webview?.postMessage;
          if (typeof webviewPostMessage === 'function') {
            try {
              webviewPostMessage({ type: 'png-export-progress', status: statusObj });
            } catch (postError) {
              console.warn('chrome.webview.postMessage failed', postError);
            }
            return;
          }

          // Fallback for other hosts - window.external may be deprecated but check safely on globalThis
          const externalNotify = globalThis.external?.notify;
          if (typeof externalNotify === 'function') {
            try {
              externalNotify(JSON.stringify({ type: 'png-export-progress', status: statusObj }));
            } catch (exportProgressError) {
              console.warn('external.notify failed', exportProgressError);
            }
          }
        } catch (statusError) {
          // Ignore status delivery errors - keep working locally
          console.warn('Failed to set or notify export status', statusError);
        }
      };

      try {
        // Set status for polling
        setExportStatus({
          step: 'initializing',
          percent: 0,
          message: 'Starting PNG export...'
        });

        // Validate we have diagram source
        if (!globalThis.lastMermaidSource) {
          throw new Error('No diagram source available for export');
        }

        // Parse options with defaults
        const scale = options?.scale || 2;
        const backgroundColor = options?.backgroundColor || 'white';
        const dpi = options?.dpi || 96;

        // Calculate DPI scale (96 is the baseline DPI)
        const dpiScale = dpi / 96;
        const effectiveScale = scale * dpiScale;

        console.log(`Using scale: ${scale}, DPI: ${dpi}, effective scale: ${effectiveScale}`);

        // Update progress: Rendering
        setExportStatus({
          step: 'rendering',
          percent: 20,
          message: 'Rendering diagram...'
        });

        // Render fresh SVG with current config
        const id = `png-export-${Date.now()}`;
        const renderResult = await globalThis.mermaid.render(id, globalThis.lastMermaidSource);

        if (!renderResult?.svg) {
          throw new Error('Failed to render diagram for PNG export');
        }

        // Update progress: Creating canvas
        setExportStatus({
          step: 'creating-canvas',
          percent: 40,
          message: 'Creating canvas...'
        });

        // Create temporary container for SVG
        const container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.left = '-99999px';
        container.style.top = '-99999px';
        container.innerHTML = renderResult.svg;
        document.body.appendChild(container);

        const svgElement = container.querySelector('svg');
        if (!svgElement) {
          container.remove();
          throw new Error('Could not find SVG element in rendered output');
        }

        // Get dimensions from viewBox or bounding box
        const viewBox = svgElement.getAttribute('viewBox');
        let width, height;

        if (viewBox) {
          const parts = viewBox.split(' ');
          width = Number.parseFloat(parts[2]);
          height = Number.parseFloat(parts[3]);
        } else {
          const bbox = svgElement.getBoundingClientRect();
          width = bbox.width || 800;
          height = bbox.height || 600;
        }

        const scaledWidth = Math.round(width * effectiveScale);
        const scaledHeight = Math.round(height * effectiveScale);
        const totalPixels = scaledWidth * scaledHeight;
        const estimatedMemoryMB = (totalPixels * 4) / (1024 * 1024); // 4 bytes per pixel

        console.log(`SVG dimensions: ${width}x${height}, scaled: ${scaledWidth}x${scaledHeight}`);
        console.log(`Total pixels: ${totalPixels.toLocaleString()}, estimated memory: ${estimatedMemoryMB.toFixed(0)} MB`);

        // Validate canvas size limits
        const maxDimension = 32767; // Browser spec limit per dimension
        const maxPixels = 16384 * 16384; // 16384 x 16384 = 256M pixels (practical limit)
        const maxMemoryMB = 1024; // 1 GB practical memory limit

        if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
          container.remove();
          throw new Error(`Canvas dimension exceeds browser limit of ${maxDimension} pixels. Current: ${scaledWidth}x${scaledHeight}. Try reducing scale or DPI.`);
        }

        if (totalPixels > maxPixels) {
          container.remove();
          const oneMillion = 1000000;
          throw new Error(`Canvas size too large (${(totalPixels / oneMillion).toFixed(1)}M pixels). Maximum recommended: ${(maxPixels / oneMillion).toFixed(0)}M pixels. Try reducing scale or DPI.`);
        }

        if (estimatedMemoryMB > maxMemoryMB) {
          container.remove();
          throw new Error(`Estimated memory usage (${estimatedMemoryMB.toFixed(0)} MB) exceeds safe limit of ${maxMemoryMB} MB. Try reducing scale or DPI.`);
        }

        // Update progress: Converting to bitmap
        setExportStatus({
          step: 'converting',
          percent: 60,
          message: 'Converting to bitmap...'
        });

        // Create canvas with scaled dimensions
        const canvas = document.createElement('canvas');
        canvas.width = scaledWidth;
        canvas.height = scaledHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          container.remove();
          throw new Error('Failed to get canvas 2D context');
        }

        // Scale context for high-DPI rendering
        ctx.scale(effectiveScale, effectiveScale);

        // Draw background if not transparent
        if (backgroundColor && backgroundColor.toLowerCase() !== 'transparent') {
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(0, 0, width, height);
        }

        // Serialize SVG to string
        const svgString = new XMLSerializer().serializeToString(svgElement);

        // Clean up DOM
        container.remove();

        // Convert SVG to data URI (avoids canvas tainting issues with blob URLs)
        // Encode the SVG string properly for data URI
        const encodedSvg = encodeURIComponent(svgString)
          .replaceAll('\'', '%27')
          .replaceAll('"', '%22');

        const dataUri = `data:image/svg+xml;charset=utf-8,${encodedSvg}`;

        // Load SVG into image
        const img = new Image();

        // Create promise for image loading
        const imageLoadPromise = new Promise((resolve, reject) => {
          img.onload = () => {
            resolve();
          };

          img.onerror = (error) => {
            reject(new Error(`Failed to load SVG as image: ${error}`));
          };

          // Set timeout for image loading (30 seconds)
          setTimeout(() => {
            reject(new Error('Image loading timeout'));
          }, 30000);
        });

        img.src = dataUri;
        await imageLoadPromise;

        // Update progress: Drawing to canvas
        setExportStatus({
          step: 'drawing',
          percent: 80,
          message: 'Drawing to canvas...'
        });

        // Draw image to canvas
        ctx.drawImage(img, 0, 0, width, height);

        // Update progress: Encoding
        setExportStatus({
          step: 'encoding',
          percent: 90,
          message: 'Encoding PNG...'
        });

        // Convert canvas to PNG data URL
        const dataUrl = canvas.toDataURL('image/png');

        // Validate that toDataURL() succeeded
        // Some browsers return 'data:,' if canvas.toDataURL() fails (e.g., canvas is empty, too large, or encoding error)
        if (!dataUrl || dataUrl === 'data:,' || !dataUrl.includes(',')) {
          throw new Error('Failed to encode canvas to PNG. The canvas size may be too large for this browser. Try reducing scale or DPI.');
        }

        // Extract base64 data (remove "data:image/png;base64," prefix)
        const base64Data = dataUrl.split(',')[1];

        // Validate base64 data
        if (!base64Data || base64Data.length === 0) {
          throw new Error('PNG encoding produced empty data. Try reducing scale or DPI.');
        }

        // Update progress: Complete
        setExportStatus({
          step: 'complete',
          percent: 100,
          message: 'Export complete!'
        });

        console.log('PNG export successful, data length:', base64Data.length);

        // Store result for retrieval
        globalThis.__pngExportResult__ = base64Data;

        // Notify host that result is available (lightweight notification)
        try {
          const webviewPostMessage = globalThis.chrome?.webview?.postMessage;
          if (typeof webviewPostMessage === 'function') {
            webviewPostMessage({ type: 'png-export-complete', length: base64Data.length });
          } else {
            const externalNotify = globalThis.external?.notify;
            if (typeof externalNotify === 'function') {
              externalNotify(JSON.stringify({ type: 'png-export-complete', length: base64Data.length }));
            }
          }
        } catch (e) {
          // log notification errors
          console.error('Error notifying host that result is available', e);
        }

        return {
          success: true,
          dataLength: base64Data.length,
          dimensions: { width: canvas.width, height: canvas.height }
        };

      } catch (error) {
        console.error('PNG export failed:', error);

        setExportStatus({
          step: 'error',
          percent: 0,
          message: error.message
        });

        globalThis.__pngExportResult__ = null;

        return {
          success: false,
          error: error.message
        };
      }
    };

    console.log('Browser-based PNG export function registered: globalThis.exportToPNG');

    // Legacy export functions (kept for compatibility)
    globalThis.exportDiagram = {
      getSVG: () => {
        try {
          const svg = document.querySelector('#output svg');
          if (!svg) {
            console.error('No SVG found in output');
            return null;
          }

          // Clone and ensure proper attributes
          const clone = svg.cloneNode(true);
          clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

          // Mermaid already includes styles, just serialize
          return new XMLSerializer().serializeToString(clone);
        } catch (error) {
          console.error('Error getting SVG:', error);
          return null;
        }
      }
    };

    // ==========================================
    // HOVER ENHANCEMENT FUNCTION
    // Adds invisible wider hit areas to paths/lines for easier hovering
    // Uses a single delegated event listener to avoid memory leaks
    // Uses event delegation on OUTPUT container (persists across renders)
    // Hit areas are recreated on each render (inside SVG which gets replaced)
    // ==========================================
    globalThis.enhanceHoverability = function () {
      const hitAreaWidth = 20; // Adjustable hover detection width in pixels
      const output = document.getElementById('output');
      if (!output) return;

      const svg = output.querySelector('svg');
      if (!svg) return;

      // Check if event delegation is already initialized on OUTPUT container
      // (OUTPUT persists across renders, unlike SVG which gets replaced)
      const isInitialized = !!output.dataset.hoverDelegationInit;

      // Helper function to create hit area for an element
      const createHitArea = (element) => {
        if (element.dataset.hoverEnhanced) {
          console.debug('Skipping already-enhanced element', element);
          return;
        }

        const hitArea = element.cloneNode(false);
        hitArea.classList.add('hit-area');
        hitArea.dataset.hoverEnhanced = 'true';

        // Remove marker attributes to prevent oversized markers from rendering on hit areas
        hitArea.removeAttribute('marker-end');
        hitArea.removeAttribute('marker-start');
        hitArea.removeAttribute('marker-mid');
        hitArea.removeAttribute('fill'); // Remove fill attribute to ensure inline style.fill = 'none' takes effect without attribute interference

        hitArea.style.strokeWidth = `${hitAreaWidth}px`;
        hitArea.style.stroke = 'transparent';
        hitArea.style.fill = 'none';
        hitArea.style.pointerEvents = 'stroke';
        hitArea.style.cursor = 'pointer';

        // Insert the hit area immediately after the original element (stable sibling relationship)
        element.parentNode.insertBefore(hitArea, element.nextSibling);
        element.dataset.hoverEnhanced = 'true';
        element.dataset.hoverTarget = 'true';
      };

      // Find all paths and lines that need hit areas
      const paths = svg.querySelectorAll('path.flowchart-link, .edgePath path, path[class*="edge"], path[marker-end]');
      const lines = svg.querySelectorAll('line.messageLine, line[class*="edge"], line[marker-end]');

      // Create hit areas for paths
      for (const path of paths) {
        createHitArea(path);
      }

      // Create hit areas for lines
      for (const line of lines) {
        createHitArea(line);
      }

      // Only attach event listeners ONCE to the OUTPUT container
      // These listeners persist across renders since OUTPUT doesn't get replaced
      if (!isInitialized) {
        // Use event delegation on OUTPUT container (not SVG which gets replaced)
        output.addEventListener('mouseover', (e) => {
          // Early exit: Skip if not hovering over SVG elements (performance optimization)
          if (!e.target.closest('svg')) return;

          const hitArea = e.target.closest('.hit-area');
          if (!hitArea) return;

          // Get original element via previousElementSibling (O(1) fast, stable in our architecture)
          // Safe because: hit area is inserted immediately after original, and SVG is replaced entirely on each render
          const original = hitArea.previousElementSibling;
          if (original?.dataset?.hoverTarget) {
            original.classList.add('hover-active');
          }
        }, { capture: true });

        output.addEventListener('mouseout', (e) => {
          // Early exit: Skip if not hovering over SVG elements (performance optimization)
          if (!e.target.closest('svg')) return;

          const hitArea = e.target.closest('.hit-area');
          if (!hitArea) return;

          // Check if we're actually leaving the hit-area, not just moving to a child element
          // relatedTarget is where the mouse is moving TO
          if (hitArea.contains(e.relatedTarget)) return;

          // Get original element via previousElementSibling (O(1) fast, stable in our architecture)
          // Safe because: hit area is inserted immediately after original, and SVG is replaced entirely on each render
          const original = hitArea.previousElementSibling;
          if (original?.dataset?.hoverTarget) {
            original.classList.remove('hover-active');
          }
        }, { capture: true });

        // Mark OUTPUT container as initialized (persists across SVG replacements)
        output.dataset.hoverDelegationInit = 'true';

        console.debug('Hover event delegation initialized (one-time setup)');
      }

      // Log hit area creation on first render only (when event delegation is first initialized)
      if (!isInitialized && paths.length + lines.length > 0) {
        console.debug(`Created hit areas for ${paths.length} paths and ${lines.length} lines`);
      }
    };

    // ==========================================
    // DIAGRAM DIMENSIONS FUNCTION
    // Returns the current SVG diagram dimensions for display in the UI
    // ==========================================
    globalThis.getDiagramDimensions = function () {
      try {
        const svg = document.querySelector('#output svg');
        if (!svg) {
          return JSON.stringify({ width: null, height: null });
        }

        let width, height;

        // Try viewBox first (most reliable for SVG dimensions)
        const viewBox = svg.getAttribute('viewBox');
        if (viewBox) {
          const parts = viewBox.split(/[\s,]+/);
          if (parts.length >= 4) {
            width = Number.parseFloat(parts[2]);
            height = Number.parseFloat(parts[3]);
          }
        }

        // Fallback to width/height attributes or bounding box
        if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height)) {
          // Try explicit width/height attributes
          const widthAttr = svg.getAttribute('width');
          const heightAttr = svg.getAttribute('height');

          if (widthAttr && heightAttr) {
            width = Number.parseFloat(widthAttr);
            height = Number.parseFloat(heightAttr);
          }

          // Final fallback: bounding box
          if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height)) {
            const bbox = svg.getBoundingClientRect();
            width = bbox.width || null;
            height = bbox.height || null;
          }
        }

        // Validate we got reasonable dimensions
        if (!width || !height || width <= 0 || height <= 0) {
          return JSON.stringify({ width: null, height: null });
        }

        return JSON.stringify({ width, height });
      } catch (error) {
        console.error('Error getting diagram dimensions:', error);
        return JSON.stringify({ width: null, height: null });
      }
    };

    (function () {
      // Prevent the WebView from navigating to a file when one is dragged/dropped onto the page.
      // (Prevents the default browser behavior of opening the dropped file.)
      function cancelExternalFileDrop(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      globalThis.addEventListener("dragover", cancelExternalFileDrop, false);
      globalThis.addEventListener("drop", cancelExternalFileDrop, false);
    })();
  </script>
</head>
<body>
  <div id="loading-container">
    <div class="spinner"></div>
    <div id="loading-status">Initializing...</div>
  </div>
  <div id="output"></div>
</body>
</html>
